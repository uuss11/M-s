<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AR Smart Engine V5.1</title>
<style>
  :root { --primary: #00d1b2; --bg: #0a0a0a; }
  body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  
  /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª */
  #instructions {
    position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.7);
    color: white; padding: 15px; border-radius: 12px; border-right: 4px solid var(--primary);
    z-index: 100; pointer-events: none; backdrop-filter: blur(5px);
  }
  #instructions h3 { margin: 0 0 10px 0; color: var(--primary); font-size: 1rem; }
  #instructions ul { margin: 0; padding: 0 15px 0 0; list-style: none; font-size: 0.85rem; }
  #instructions li { margin-bottom: 5px; opacity: 0.9; }

  #camPreview { position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
  canvas { position: fixed; inset: 0; z-index: 10; pointer-events: none; }
  
  #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; color: white; text-align: center; }
  button { padding: 15px 50px; border-radius: 50px; border: none; background: var(--primary); color: white; cursor: pointer; font-size: 1.2rem; font-weight: bold; transition: 0.3s; box-shadow: 0 0 20px rgba(0, 209, 178, 0.4); }
  button:hover { transform: scale(1.05); background: #00f0ce; }
  
  #status { position: fixed; bottom: 20px; width: 100%; text-align: center; color: var(--primary); z-index: 100; font-weight: bold; text-shadow: 0 0 10px #000; letter-spacing: 1px; }
</style>
</head>
<body>

<div id="instructions">
  <h3>ğŸ® Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø³Ø±ÙŠØ¹:</h3>
  <ul>
    <li>âœ¨ <b>ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø³Ù…:</b> ÙŠØªØ­ÙƒÙ… ÙÙŠ Ù…ÙˆÙ‚Ø¹ ÙˆØ´ÙƒÙ„ "Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ©".</li>
    <li>ğŸ¤ <b>Ø­Ø±ÙƒØ© Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ:</b> (Ø¥Ø¨Ù‡Ø§Ù… + Ø³Ø¨Ø§Ø¨Ø©) Ù„ØªØºÙŠÙŠØ± ØªÙˆÙ‡Ø¬ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª.</li>
    <li>ğŸ—£ï¸ <b>Ø£ÙˆØ§Ù…Ø± ØµÙˆØªÙŠØ©:</b> Ù‚Ù„ "Ø£Ø­Ù…Ø±"ØŒ "Ø£Ø®Ø¶Ø±"ØŒ Ø£Ùˆ "Ø£Ø²Ø±Ù‚".</li>
  </ul>
</div>

<div id="overlay">
  <h1 style="font-size: 2.5rem; margin-bottom: 10px;">AR SMART ENGINE <span style="color:var(--primary)">V5.1</span></h1>
  <p style="margin-bottom: 30px; opacity: 0.7;">Ù†Ø¸Ø§Ù… ØªØªØ¨Ø¹ Ø°ÙƒÙŠ Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„Ù…ØªØµÙØ­</p>
  <button id="startButton">ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¢Ù†</button>
</div>

<div id="status">Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ´ØºÙŠÙ„...</div>
<video id="camPreview" playsinline muted></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 80;

// --- Ø¥Ø¶Ø§ÙØ© Ø£Ø´ÙƒØ§Ù„ Ø¬Ø¯ÙŠØ¯Ø© (Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© - Torus Knot) ---
const knotGeo = new THREE.TorusKnotGeometry(10, 3, 100, 16);
const knotMat = new THREE.MeshNormalMaterial({ wireframe: true, transparent: true, opacity: 0.4 });
const torusKnot = new THREE.Mesh(knotGeo, knotMat);
scene.add(torusKnot);

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª Ø§Ù„Ù…Ø·ÙˆØ±
const COUNT = 2000;
const posArr = new Float32Array(COUNT * 3);
const colArr = new Float32Array(COUNT * 3);
for(let i=0; i<COUNT*3; i++) posArr[i] = (Math.random()-0.5)*200;

const geo = new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
const mat = new THREE.PointsMaterial({ size: 0.8, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Ø®ÙŠÙˆØ· Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¹Ø¸Ù…ÙŠ
const lineGeo = new THREE.BufferGeometry();
const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.5 });
const allLines = new THREE.LineSegments(lineGeo, lineMat);
scene.add(allLines);

let targetPos = new THREE.Vector3(0,0,0);
let scaleVal = 1;
let pColor = new THREE.Color(0x00ffff);

// Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù„Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
function to3D(lm) {
    if(!lm) return null;
    return new THREE.Vector3(-(lm.x - 0.5) * 120, -(lm.y - 0.5) * 90, -lm.z * 60);
}

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ø°ÙƒÙŠ (Holistic)
const holistic = new window.Holistic({ 
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}` 
});
holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5 });

holistic.onResults((res) => {
    const points = [];
    
    // ØªØªØ¨Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø³Ù… Ù„ØªØºÙŠÙŠØ± Ù…ÙƒØ§Ù† Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ©
    if (res.poseLandmarks) {
        const nose = res.poseLandmarks[0];
        const nose3D = to3D(nose);
        torusKnot.position.lerp(nose3D, 0.1); // Ø§Ù„Ø¹Ù‚Ø¯Ø© ØªØªØ¨Ø¹ Ø§Ù„Ø±Ø£Ø³
        
        const poseConn = [[11,12], [11,13], [13,15], [12,14], [14,16], [11,23], [12,24]];
        poseConn.forEach(([a, b]) => {
            const p1 = to3D(res.poseLandmarks[a]);
            const p2 = to3D(res.poseLandmarks[b]);
            if(p1 && p2) points.push(p1, p2);
        });
    }

    // ØªØªØ¨Ø¹ Ø§Ù„ÙŠØ¯ Ø§Ù„ÙŠÙ…Ù†Ù‰ Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
    if (res.rightHandLandmarks) {
        const hand = res.rightHandLandmarks;
        targetPos.lerp(to3D(hand[8]), 0.2);
        
        const dist = Math.hypot(hand[8].x - hand[4].x, hand[8].y - hand[4].y);
        if(dist < 0.05) {
            statusText.innerText = "ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ Ù†Ø´Ø· ğŸ¤ - Ø¬Ø²ÙŠØ¦Ø§Øª Ù…Ø¶ØºÙˆØ·Ø©";
            pColor.set(0xff8800);
            scaleVal = 0.3;
        } else {
            pColor.set(0x00ffff);
            scaleVal = 1.0;
            statusText.innerText = "ØªØ­ÙƒÙ… Ø­Ø± - Ø­Ø±Ùƒ ÙŠØ¯Ùƒ Ù„Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„ÙØ¶Ø§Ø¡";
        }
    }

    if(points.length > 0) {
        lineGeo.setFromPoints(points);
        allLines.visible = true;
    } else {
        allLines.visible = false;
    }
});

// Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØµÙˆØªÙŠØ©
const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
if(Speech) {
    const rec = new Speech();
    rec.continuous = true;
    rec.lang = 'ar-SA';
    rec.onresult = (e) => {
        const cmd = e.results[e.results.length-1][0].transcript;
        if(cmd.includes("Ø£Ø­Ù…Ø±")) pColor.set(0xff3300);
        if(cmd.includes("Ø£Ø®Ø¶Ø±")) pColor.set(0x33ff00);
        if(cmd.includes("Ø£Ø²Ø±Ù‚")) pColor.set(0x00aaff);
    };
    rec.start();
}

function animate() {
    requestAnimationFrame(animate);
    
    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø±
    torusKnot.rotation.y += 0.01;
    torusKnot.rotation.z += 0.005;

    const pos = geo.attributes.position;
    const col = geo.attributes.color;

    for (let i = 0; i < COUNT; i++) {
        const phi = Math.acos(-1 + 2*i/COUNT);
        const th = Math.sqrt(COUNT*Math.PI)*phi;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†ÙŠØ© Ù„Ù„Ø¬Ø²ÙŠØ¦Ø§Øª Ø­ÙˆÙ„ Ù†Ù‚Ø·Ø© Ø§Ù„Ù‡Ø¯Ù
        const tx = Math.cos(th)*Math.sin(phi) * 20 * scaleVal + targetPos.x;
        const ty = Math.sin(th)*Math.sin(phi) * 20 * scaleVal + targetPos.y;
        const tz = Math.cos(phi) * 20 * scaleVal + targetPos.z;

        posArr[i*3] += (tx - posArr[i*3]) * 0.1;
        posArr[i*3+1] += (ty - posArr[i*3+1]) * 0.1;
        posArr[i*3+2] += (tz - posArr[i*3+2]) * 0.1;

        col.setXYZ(i, pColor.r, pColor.g, pColor.b);
    }
    pos.needsUpdate = true;
    col.needsUpdate = true;
    renderer.render(scene, camera);
}

startButton.onclick = () => {
    overlay.style.display = 'none';
    const cameraHelper = new window.Camera(videoEl, {
        onFrame: async () => { await holistic.send({ image: videoEl }); },
        width: 1280, height: 720
    });
    cameraHelper.start();
    animate();
    statusText.innerText = "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… - Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø­Ø±ÙƒØ©";
};

// ØªØ­Ø¯ÙŠØ« Ø­Ø¬Ù… Ø§Ù„Ø´Ø§Ø´Ø©
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
