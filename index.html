<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ØªØ­ÙƒÙ… Ø§Ø­ØªØ±Ø§ÙÙŠ Ø¨Ø§Ù„ÙŠØ¯ÙŠÙ† ÙˆØ§Ù„ÙÙ…</title>
<style>
  body{margin:0;overflow:hidden;background:#000;color:#fff;font-family:Segoe UI,Arial}
  canvas{display:block}
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;z-index:1000;flex-direction:column;gap:10px}
  button{padding:12px 25px;border-radius:999px;border:none;background:#ff4757;color:#fff;cursor:pointer;font-size:1.1rem;transition:0.3s}
  button:hover{background:#ff6b81;transform:scale(1.05)}
  #status{position:fixed;bottom:12px;left:0;right:0;text-align:center;z-index:40;color:#00ff88;font-weight:bold}
  #legend{position:fixed;top:12px;left:12px;padding:12px;background:rgba(0,0,0,.6);backdrop-filter:blur(8px);border-radius:12px;z-index:40;font-size:.85rem;border:1px solid rgba(255,255,255,0.1)}
  /* Ø´ÙƒÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø§Ù„Ø¬Ù…ÙŠÙ„ */
  #camBox{position:fixed;bottom:12px;right:12px;width:220px;height:160px;border-radius:15px;overflow:hidden;z-index:50;border:2px solid #ff4757;background:#000;box-shadow: 0 0 15px rgba(255,71,87,0.3)}
  #camBox video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
</style>
</head>
<body>

<div id="overlay">
  <h2 style="margin:0">Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… (ÙŠØ¯ÙŠÙ† + ÙÙ…)</h2>
  <p style="color:#ccc">Ø§Ø³ØªØ®Ø¯Ù… ÙŠØ¯ÙŠÙƒ Ø§Ù„Ø§Ø«Ù†ØªÙŠÙ† Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ù…ÙƒØ§Ù†</p>
  <button id="startButton">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†</button>
</div>

<div id="status">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>

<div id="legend">
  <b>ğŸ® Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ âœŒï¸:</b><br>
  â€¢ ÙŠØ¯ ÙˆØ§Ø­Ø¯Ø©: ÙŠØªØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø©.<br>
  â€¢ ÙŠØ¯ÙŠÙ†: Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Ø§Ù„Ù…Ù†ØªØµÙ) ÙˆØ§Ù„Ø­Ø¬Ù… (Ø§Ù„Ù…Ø³Ø§ÙØ©).<br>
  â€¢ Ù‚Ø¨Ø¶ Ø§Ù„ÙŠØ¯: Ø´ÙƒÙ„ â¤ï¸<br>
  â€¢ ÙØªØ­ Ø§Ù„ÙÙ… ğŸ‘„: ØªÙØ¬ÙŠØ± Ø§Ù„Ø´Ø±Ø§Ø± Ø¨Ø¹ÙŠØ¯Ø§Ù‹.<br>
  â€¢ ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„ÙŠØ¯ÙŠÙ† Ø¬Ø¯Ø§Ù‹: ØªØ«Ø¨ÙŠØª/Ø¥Ù„ØºØ§Ø¡ ØªØ«Ø¨ÙŠØª Ø§Ù„Ø´ÙƒÙ„.<br>
</div>

<div id="camBox"><video id="camPreview" autoplay muted playsinline></video></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 80;

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª (Ø§Ù„Ø´Ø±Ø§Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…)
const COUNT = 1600;
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const vel = new Float32Array(COUNT*3);

for(let i=0;i<COUNT;i++){
  positions[i*3] = (Math.random()-.5)*150;
  positions[i*3+1] = (Math.random()-.5)*150;
  positions[i*3+2] = (Math.random()-.5)*150;
  vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
geo.setAttribute('color', new THREE.BufferAttribute(colors,3));

const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
const mat = new THREE.PointsMaterial({ size: 0.8, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending, map:sprite, depthWrite:false });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙŠØ¯ÙŠÙ† (Ù„Ù„Ø±Ø³Ù…)
const handGroup = new THREE.Group();
scene.add(handGroup);
const handLinesArray = [];

function createHandMesh() {
    const g = new THREE.BufferGeometry();
    const m = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.6 });
    const l = new THREE.LineSegments(g, m);
    handGroup.add(l);
    return { geometry: g, lines: l };
}
const hand1 = createHandMesh();
const hand2 = createHandMesh();

// Ø§Ù„Ø«ÙˆØ§Ø¨Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø£Ø´ÙƒØ§Ù„
const heart = (t) => new THREE.Vector3(16*Math.pow(Math.sin(t),3), 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t), 0);
const spherePoint = (i) => {
    const phi = Math.acos(-1 + 2*i/COUNT);
    const th = Math.sqrt(COUNT*Math.PI)*phi;
    return new THREE.Vector3().setFromSphericalCoords(20, phi, th);
};

// Ø§Ù„Ø­Ø§Ù„Ø© (State)
let handPos = new THREE.Vector3(0,0,0);
let scaleVal = 1;
let currentShape = 'sphere';
let isPinned = false;
let colorMode = 0;
const cooldown = { mouth: 0, pin: 0 };

function lmToScene(lm) {
    return new THREE.Vector3((lm.x - 0.5) * 110, -(lm.y - 0.5) * 80, -lm.z * 50);
}

// Ø¥Ø¹Ø¯Ø§Ø¯ Mediapipe
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true });

hands.onResults((res) => {
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        statusText.innerText = res.multiHandLandmarks.length === 2 ? "ØªØ­ÙƒÙ… Ø«Ù†Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„ âœŒï¸" : "ÙŠØªÙ… Ø§Ù„ØªØ­ÙƒÙ… Ø¨ÙŠØ¯ ÙˆØ§Ø­Ø¯Ø©";
        
        let p1 = lmToScene(res.multiHandLandmarks[0][8]); // Ø³Ø¨Ø§Ø¨Ø© Ø§Ù„ÙŠØ¯ 1
        
        if (res.multiHandLandmarks.length === 2) {
            let p2 = lmToScene(res.multiHandLandmarks[1][8]); // Ø³Ø¨Ø§Ø¨Ø© Ø§Ù„ÙŠØ¯ 2
            
            if (!isPinned) {
                handPos.lerp(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5), 0.2);
                let dist = p1.distanceTo(p2);
                scaleVal = THREE.MathUtils.lerp(scaleVal, dist / 25, 0.1);
            }

            // Ø­Ø±ÙƒØ© Ø§Ù„ØªØ«Ø¨ÙŠØª (ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„ÙŠØ¯ÙŠÙ† Ø¬Ø¯Ø§Ù‹)
            if (p1.distanceTo(p2) < 5 && Date.now() - cooldown.pin > 1500) {
                isPinned = !isPinned;
                cooldown.pin = Date.now();
                statusText.innerText = isPinned ? "ØªÙ… ØªØ«Ø¨ÙŠØª Ø§Ù„Ø´ÙƒÙ„ ÙÙŠ Ø§Ù„ÙØ¶Ø§Ø¡ ğŸ“" : "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ«Ø¨ÙŠØª";
            }
        } else {
            if (!isPinned) handPos.lerp(p1, 0.2);
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´ÙƒÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù‚Ø¨Ø¶Ø© Ø§Ù„ÙŠØ¯
        const lm = res.multiHandLandmarks[0];
        currentShape = (lm[8].y > lm[6].y && lm[12].y > lm[10].y) ? 'heart' : 'sphere';
        
        updateHandSkeleton(res.multiHandLandmarks);
    } else {
        statusText.innerText = "Ø£Ø¸Ù‡Ø± ÙŠØ¯ÙŠÙƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§...";
        hand1.lines.visible = false;
        hand2.lines.visible = false;
    }
});

function updateHandSkeleton(allLms) {
    [hand1, hand2].forEach((h, i) => {
        if (allLms[i]) {
            h.lines.visible = true;
            const pts = [];
            const conn = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            conn.forEach(([a,b]) => {
                pts.push(lmToScene(allLms[i][a]), lmToScene(allLms[i][b]));
            });
            h.geometry.setFromPoints(pts);
        } else {
            h.lines.visible = false;
        }
    });
}

faceMesh.onResults((res) => {
    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
        const fl = res.multiFaceLandmarks[0];
        const topLip = fl[13], botLip = fl[14];
        if (Math.abs(topLip.y - botLip.y) > 0.04 && Date.now() - cooldown.mouth > 1000) {
            cooldown.mouth = Date.now();
            statusText.innerText = "ğŸ‘„ ØªÙØ¬ÙŠØ± Ø§Ù„ÙÙ…!";
            for (let i = 0; i < COUNT; i++) {
                vel[i*3] += (Math.random()-0.5) * 60;
                vel[i*3+1] += (Math.random()-0.5) * 60;
                vel[i*3+2] += (Math.random()-0.5) * 60;
            }
        }
    }
});

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.002;
    const posAttr = geo.attributes.position;
    const colAttr = geo.attributes.color;

    for (let i = 0; i < COUNT; i++) {
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ (Ø§Ù„Ø³Ø±Ø¹Ø©)
        positions[i*3] += vel[i*3] * 0.05;
        positions[i*3+1] += vel[i*3+1] * 0.05;
        positions[i*3+2] += vel[i*3+2] * 0.05;

        // Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ø¯Ø§ÙØ¹Ø© Ù„Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø´ÙƒÙ„
        let target;
        if (currentShape === 'heart') {
            target = heart((i/COUNT)*Math.PI*2).multiplyScalar(scaleVal * 1.5);
        } else {
            target = spherePoint(i).multiplyScalar(scaleVal);
        }

        const tx = target.x + handPos.x;
        const ty = target.y + handPos.y;
        const tz = target.z + handPos.z;

        positions[i*3] += (tx - positions[i*3]) * 0.08;
        positions[i*3+1] += (ty - positions[i*3+1]) * 0.08;
        positions[i*3+2] += (tz - positions[i*3+2]) * 0.08;

        // ØªØ¨Ø§Ø·Ø¤ Ø§Ù„Ø³Ø±Ø¹Ø© (Damping)
        vel[i*3] *= 0.9; vel[i*3+1] *= 0.9; vel[i*3+2] *= 0.9;

        posAttr.setXYZ(i, positions[i*3], positions[i*3+1], positions[i*3+2]);
        
        // Ø§Ù„Ø£Ù„ÙˆØ§Ù† (ØªØªØºÙŠØ± Ù…Ø¹ Ø§Ù„Ø­Ø±ÙƒØ©)
        const hue = (Math.sin(time + i/COUNT) * 0.5 + 0.5);
        if(currentShape === 'heart') colAttr.setXYZ(i, 1, 0.2, 0.3);
        else colAttr.setXYZ(i, 0.2, hue, 1);
    }

    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    particles.rotation.y += 0.005;
    renderer.render(scene, camera);
}

startButton.onclick = async () => {
    overlay.style.display = 'none';
    const cam = new Camera(videoEl, {
        onFrame: async () => {
            await hands.send({ image: videoEl });
            await faceMesh.send({ image: videoEl });
        },
        width: 640, height: 480
    });
    cam.start();
    animate();
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
