<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ØªØ­ÙƒÙ… ÙƒØ§Ù…Ù„ Ø§Ù„Ø´Ø§Ø´Ø© - ÙŠØ¯ÙŠÙ† ÙˆÙÙ…</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: Segoe UI, Arial; }
  
  /* Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø®Ù„ÙÙŠØ© ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ø´Ø§Ø´Ø© */
  #camPreview {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    object-fit: cover; transform: scaleX(-1); z-index: 1;
  }

  /* Ø§Ù„Ø±Ø³Ù… (Ø§Ù„Ø´Ø±Ø§Ø± ÙˆØ§Ù„Ø®Ø·ÙˆØ·) ÙÙˆÙ‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ */
  canvas { position: fixed; top: 0; left: 0; z-index: 10; pointer-events: none; }

  #overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.8);
    display: flex; align-items: center; justify-content: center;
    z-index: 1000; flex-direction: column; color: white; text-align: center;
  }
  button {
    padding: 15px 35px; border-radius: 50px; border: none;
    background: #00d1b2; color: white; cursor: pointer; font-size: 1.2rem;
  }
  #status {
    position: fixed; top: 20px; width: 100%; text-align: center;
    color: #00ff88; font-weight: bold; z-index: 100; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
  }
  #legend {
    position: fixed; bottom: 20px; left: 20px; padding: 15px;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(5px);
    color: white; border-radius: 15px; z-index: 100; font-size: 0.85rem;
  }
</style>
</head>
<body>

<div id="overlay">
  <h2>Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø¹Ø²Ø² (AR)</h2>
  <p>Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø³ØªÙƒÙˆÙ† Ø®Ù„ÙÙŠØ© Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø®Ø·ÙˆØ· Ù…Ø¹ ÙŠØ¯Ùƒ ØªÙ…Ø§Ù…Ø§Ù‹</p>
  <button id="startButton">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ¬Ø±Ø¨Ø©</button>
</div>

<div id="status">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...</div>

<div id="legend">
  <b>ğŸ® Ø§Ù„ØªØ­ÙƒÙ…:</b><br>
  â€¢ ÙŠØ¯ ÙˆØ§Ø­Ø¯Ø©: ØªØªØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø©.<br>
  â€¢ ÙŠØ¯ÙŠÙ†: ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ§Ù„Ø­Ø¬Ù… (Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ†Ù‡Ù…Ø§).<br>
  â€¢ ÙØªØ­ Ø§Ù„ÙÙ… ğŸ‘„: ØªÙØ¬ÙŠØ± Ø§Ù„Ø´Ø±Ø§Ø±.<br>
  â€¢ ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„ÙŠØ¯ÙŠÙ†: ØªØ«Ø¨ÙŠØª/ØªØ­Ø±ÙŠØ± Ø§Ù„Ù…ÙˆÙ‚Ø¹.<br>
</div>

<video id="camPreview" autoplay muted playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ (Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ© ØªÙ…Ø§Ù…Ø§Ù‹)
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0); 
document.body.appendChild(renderer.domElement);

camera.position.z = 60;

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª (Ø§Ù„Ø´Ø±Ø§Ø±)
const COUNT = 1500;
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const vel = new Float32Array(COUNT*3);

for(let i=0; i<COUNT; i++){
    positions[i*3] = (Math.random()-0.5)*100;
    positions[i*3+1] = (Math.random()-0.5)*100;
    positions[i*3+2] = (Math.random()-0.5)*100;
    vel[i*3] = vel[i*3+1] = vel[i*3+2] = 0;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const mat = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Ø®ÙŠÙˆØ· Ø§Ù„ÙŠØ¯ (Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¹Ø¸Ù…ÙŠ)
const createHand = () => {
    const g = new THREE.BufferGeometry();
    const m = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
    const l = new THREE.LineSegments(g, m);
    scene.add(l);
    return { geometry: g, lines: l };
};
const handMesh1 = createHand();
const handMesh2 = createHand();

// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØªÙ…Ø§Ù…Ø§Ù‹
function lmToScene(lm) {
    const x = -(lm.x - 0.5) * 75 * (window.innerWidth / window.innerHeight);
    const y = -(lm.y - 0.5) * 75;
    return new THREE.Vector3(x, y, -lm.z * 40);
}

// Ø§Ù„Ø­Ø§Ù„Ø©
let handPos = new THREE.Vector3(0,0,0);
let scaleVal = 1;
let currentShape = 'sphere';
let isPinned = false;
const cooldown = { mouth: 0, pin: 0 };

const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true });

hands.onResults((res) => {
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        statusText.innerText = "ØªÙ… Ø±ØµØ¯ Ø§Ù„ÙŠØ¯ âœ…";
        
        let p1 = lmToScene(res.multiHandLandmarks[0][8]);
        
        if (res.multiHandLandmarks.length === 2) {
            let p2 = lmToScene(res.multiHandLandmarks[1][8]);
            if (!isPinned) {
                handPos.lerp(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5), 0.2);
                scaleVal = p1.distanceTo(p2) / 20;
            }
            if (p1.distanceTo(p2) < 4 && Date.now() - cooldown.pin > 1500) {
                isPinned = !isPinned;
                cooldown.pin = Date.now();
            }
        } else {
            if (!isPinned) handPos.lerp(p1, 0.2);
        }

        // Ø´ÙƒÙ„ Ø§Ù„Ù‚Ù„Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ù‚Ø¨Ø¶Ø©
        const lm = res.multiHandLandmarks[0];
        currentShape = (lm[8].y > lm[6].y) ? 'heart' : 'sphere';

        updateSkeletons(res.multiHandLandmarks);
    } else {
        handMesh1.lines.visible = handMesh2.lines.visible = false;
    }
});

function updateSkeletons(allLms) {
    [handMesh1, handMesh2].forEach((h, i) => {
        if (allLms[i]) {
            h.lines.visible = true;
            const pts = [];
            const conn = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            conn.forEach(([a,b]) => {
                pts.push(lmToScene(allLms[i][a]), lmToScene(allLms[i][b]));
            });
            h.geometry.setFromPoints(pts);
        } else { h.lines.visible = false; }
    });
}

faceMesh.onResults((res) => {
    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
        const fl = res.multiFaceLandmarks[0];
        if (Math.abs(fl[13].y - fl[14].y) > 0.04 && Date.now() - cooldown.mouth > 1000) {
            cooldown.mouth = Date.now();
            for (let i = 0; i < COUNT; i++) {
                vel[i*3] += (Math.random()-0.5)*50;
                vel[i*3+1] += (Math.random()-0.5)*50;
                vel[i*3+2] += (Math.random()-0.5)*50;
            }
        }
    }
});

const heartFn = (t) => new THREE.Vector3(16*Math.pow(Math.sin(t),3)/1.5, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))/1.5, 0);

function animate() {
    requestAnimationFrame(animate);
    const posAttr = geo.attributes.position;
    const colAttr = geo.attributes.color;

    for (let i = 0; i < COUNT; i++) {
        positions[i*3] += vel[i*3] * 0.05;
        positions[i*3+1] += vel[i*3+1] * 0.05;
        positions[i*3+2] += vel[i*3+2] * 0.05;

        let target;
        if (currentShape === 'heart') {
            target = heartFn((i/COUNT)*Math.PI*2).multiplyScalar(scaleVal*1.5);
        } else {
            const phi = Math.acos(-1 + 2*i/COUNT);
            const th = Math.sqrt(COUNT*Math.PI)*phi;
            target = new THREE.Vector3().setFromSphericalCoords(15 * scaleVal, phi, th);
        }

        positions[i*3] += (target.x + handPos.x - positions[i*3]) * 0.1;
        positions[i*3+1] += (target.y + handPos.y - positions[i*3+1]) * 0.1;
        positions[i*3+2] += (target.z + handPos.z - positions[i*3+2]) * 0.1;

        vel[i*3] *= 0.9; vel[i*3+1] *= 0.9; vel[i*3+2] *= 0.9;
        posAttr.setXYZ(i, positions[i*3], positions[i*3+1], positions[i*3+2]);
        
        if(currentShape === 'heart') colAttr.setXYZ(i, 1, 0.2, 0.4);
        else colAttr.setXYZ(i, 0.1, 0.8, 1);
    }

    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    renderer.render(scene, camera);
}

startButton.onclick = async () => {
    overlay.style.display = 'none';
    const cam = new Camera(videoEl, {
        onFrame: async () => {
            await hands.send({ image: videoEl });
            await faceMesh.send({ image: videoEl });
        }
    });
    cam.start();
    animate();
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
