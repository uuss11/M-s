<!DOCTYPE html><html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù…Ø¹ Ø®ÙŠÙˆØ· ÙˆØªÙ…ÙŠÙŠØ² Ø§Ù„ÙÙ…</title>
  <style>
    body{margin:0;overflow:hidden;background:#000;font-family:'Segoe UI',Tahoma,Arial}
    canvas{display:block}
    #overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;z-index:1000;flex-direction:column;gap:12px}
    button{padding:12px 24px;border-radius:999px;border:none;background:#ff4757;color:#fff;cursor:pointer;font-size:1rem}
    #status{position:fixed;bottom:14px;left:0;right:0;text-align:center;color:#fff;z-index:10}
    #legend{position:fixed;top:12px;left:12px;padding:10px 12px;background:rgba(0,0,0,0.55);color:#fff;font-size:.88rem;line-height:1.6;border-radius:10px;z-index:30;backdrop-filter:blur(6px);box-shadow:0 6px 18px rgba(0,0,0,.45);max-width:260px}
    #legend b{display:block;margin-bottom:4px}
    #camBox{position:fixed;bottom:12px;right:12px;width:220px;height:160px;border-radius:12px;overflow:hidden;z-index:40;border:2px solid rgba(255,255,255,0.18);box-shadow:0 8px 30px rgba(0,0,0,.6);background:#000}
    #camBox video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
  </style>
</head>
<body><div id="overlay">
  <h2 style="color:#fff;margin:0">ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù…ÙØ­Ø³Ù‘Ù†</h2>
  <div style="color:#ddd">Ø§Ø¶ØºØ· Ø§Ø¨Ø¯Ø£ Ø«Ù… Ø³Ù…Ø­ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§</div>
  <button id="startButton">Ø§Ø¨Ø¯Ø£</button>
</div><div id="status">Ø¬Ø§Ù‡Ø²</div><div id="legend">
  <b>ğŸ® Ø­Ø±ÙƒØ§Øª Ø§Ù„ØªØ­ÙƒÙ…</b>
  ğŸ– ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø©: ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
  <br>ğŸ¤ Ù‚Ø±ØµØ©: ØªÙƒØ¨ÙŠØ± / ØªØµØºÙŠØ±
  <br>âœŒï¸ Ø¥ØµØ¨Ø¹ÙŠÙ†: ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†
  <br>ğŸ‘ Ø¥Ø¨Ù‡Ø§Ù… Ù„ÙÙˆÙƒ: ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ù…Ø¤Ù‚ØªØ§Ù‹
  <br>ğŸ¤˜ Ø±ÙˆÙƒ: ØªÙØ¬ÙŠØ± Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
  <br>ğŸ– ÙŠØ¯ Ù…ÙØªÙˆØ­Ø©: ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯
  <br>ğŸ‘‹ ØªÙ„ÙˆÙŠØ­: Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„Ù…Ø´Ù‡Ø¯
  <br>ğŸ‘„ ÙØªØ­ Ø§Ù„ÙÙ…: Ø´Ø±Ø§Ø± ÙŠØªÙ†Ø§Ø«Ø± Ø¨Ø¹ÙŠØ¯
  <br><small>Ø£Ù„ÙˆØ§Ù† ÙˆØ®ÙŠÙˆØ· Ù…Ø±Ø¦ÙŠØ© Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ¯ ÙˆØ§Ù„ÙƒÙØŒ ÙˆØ£Ø´ÙƒØ§Ù„ Ù‡Ù†Ø¯Ø³ÙŠØ© Ù„Ù…Ø§ ØªÙÙƒØªØ´Ù Ø¥Ø´Ø§Ø±Ø§Øª Ø®Ø§ØµØ©</small>
</div><div id="camBox"><video id="camPreview" autoplay muted playsinline></video></div><!-- Mediapipe libs --><script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script><script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script><script type="module">
  import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

  // Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
  const startButton = document.getElementById('startButton');
  const overlay = document.getElementById('overlay');
  const statusText = document.getElementById('status');
  const camPreview = document.getElementById('camPreview');

  // ThreeJS
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  camera.position.z = 85;

  // Ø¬Ø²ÙŠØ¦Ø§Øª
  const COUNT = 2000;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(COUNT*3);
  const col = new Float32Array(COUNT*3);
  const vel = new Float32Array(COUNT*3); // Ø³Ø±Ø¹Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø¬Ø²ÙŠØ¦Ø§Øª (Ù„Ù„Ø´Ø±Ø§Ø±)

  for(let i=0;i<COUNT;i++){
    pos[i*3]=(Math.random()-.5)*120;
    pos[i*3+1]=(Math.random()-.5)*120;
    pos[i*3+2]=(Math.random()-.5)*120;
    col[i*3]=0.6; col[i*3+1]=0.6; col[i*3+2]=1;
    vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));

  const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
  const mat = new THREE.PointsMaterial({size:0.9,vertexColors:true,transparent:true,blending:THREE.AdditiveBlending,map:sprite,depthWrite:false});
  const particles = new THREE.Points(geo,mat);
  scene.add(particles);

  // Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ø¹Ø±Ø¶ Ø®ÙŠÙˆØ· Ø§Ù„ÙŠØ¯ Ùˆ Ø§Ù„Ø£Ø´ÙƒØ§Ù„
  const handGroup = new THREE.Group();
  scene.add(handGroup);

  // Ø®Ø·ÙˆØ· Ø®ÙŠÙˆØ· Ø§Ù„Ø£ØµØ§Ø¨Ø¹
  const threadMat = new THREE.LineBasicMaterial({ linewidth: 2, transparent:true });
  const threadGeom = new THREE.BufferGeometry();
  const THREAD_POINTS = 6 * 3 * 3; // ØªÙ‚Ø±ÙŠØ¨ØŒ Ø³ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‡ÙŠØ¦ØªÙ‡ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹
  const threadPositions = new Float32Array(5 * 2 * 3); // 5 Ø£ØµØ§Ø¨Ø¹ØŒ Ø®Ø· Ù…Ù† Ø§Ù„Ù…Ø¹ØµÙ…(0) Ø¥Ù„Ù‰ Ø·Ø±Ù ÙƒÙ„ Ø¥ØµØ¨Ø¹
  threadGeom.setAttribute('position', new THREE.BufferAttribute(threadPositions,3));
  const threads = new THREE.LineSegments(threadGeom, threadMat);
  handGroup.add(threads);

  // Ø®Ø·ÙˆØ· Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙŠØ¯ (Ø§ØªØµØ§Ù„Ø§Øª Mediapipe)
  const handLineMat = new THREE.LineBasicMaterial({linewidth:2,transparent:true});
  const HAND_CONN = [
    [0,1],[1,2],[2,3],[3,4],
    [0,5],[5,6],[6,7],[7,8],
    [5,9],[9,10],[10,11],[11,12],
    [9,13],[13,14],[14,15],[15,16],
    [13,17],[17,18],[18,19],[19,20],[0,17]
  ];
  const handLinePositions = new Float32Array(HAND_CONN.length * 2 * 3);
  const handLineGeom = new THREE.BufferGeometry();
  handLineGeom.setAttribute('position', new THREE.BufferAttribute(handLinePositions,3));
  const handLines = new THREE.LineSegments(handLineGeom, handLineMat);
  handGroup.add(handLines);

  // Ø£Ø´ÙƒØ§Ù„ Ù‡Ù†Ø¯Ø³ÙŠØ© ØµØºÙŠØ±Ø© Ù„Ù„ØªÙ†Ø¨ÙŠÙ‡ (Ù…Ø±Ø¨Ø¹ Ù„Ù„ÙƒØ´ÙØŒ Ø¯Ø§Ø¦Ø±Ø© Ù„Ù„ÙÙ‡Ù…...)
  const markerGeom = new THREE.SphereGeometry(2.8, 8, 6);
  const markerMatDetect = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.9 });
  const markerMatUnderstand = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent:true, opacity:0.95 });
  const markerDetect = new THREE.Mesh(markerGeom, markerMatDetect);
  const markerUnderstand = new THREE.Mesh(markerGeom, markerMatUnderstand);
  markerDetect.visible = false; markerUnderstand.visible = false;
  handGroup.add(markerDetect); handGroup.add(markerUnderstand);

  // Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ø¯Ù
  const heart=(t)=> new THREE.Vector3(16*Math.pow(Math.sin(t),3),13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t),0);
  const sphere=(i)=>{ const phi=Math.acos(-1+2*i/COUNT); const th=Math.sqrt(COUNT*Math.PI)*phi; return new THREE.Vector3().setFromSphericalCoords(22,phi,th); };

  // Mediapipe setup
  let handX=0, handY=0, scale=1, rotSpeed=0.002, freeze=false;
  let colorMode=0;
  let currentShape='sphere';

  // ÙÙŠØ¯ÙŠÙˆ Ù…Ø®ÙÙŠ Ù„Ù€ Mediapipe
  const video = document.createElement('video');
  video.autoplay=true; video.muted=true; video.playsInline=true; video.style.display='none';
  document.body.appendChild(video);

  const hands = new Hands({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
  hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.55, minTrackingConfidence:0.55 });

  // Face Mesh for mouth detection
  const faceMesh = new FaceMesh({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
  faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });

  let lastColorTime=0, lastExplosionTime=0, lastBoostTime=0, lastResetTime=0, lastMouthTime=0;
  const COOLDOWN = 700; // ms

  // Helper: map mediapipe landmark (normalized) to scene coords
  function lmToScene(lm){
    // lm.x, lm.y are 0..1 ; center them and scale
    const x = (lm.x - 0.5) * window.innerWidth * 0.06;
    const y = -(lm.y - 0.5) * window.innerHeight * 0.045;
    const z = (lm.z || 0) * 40; // z is usually small negative
    return new THREE.Vector3(x, y, z);
  }

  // ØªØ­Ø¯ÙŠØ« Ø®Ø·ÙˆØ· Ø§Ù„ÙŠØ¯
  function updateHandVisuals(landmarks){
    if(!landmarks) { threads.visible=false; handLines.visible=false; markerDetect.visible=false; markerUnderstand.visible=false; return; }
    threads.visible=true; handLines.visible=true;
    // wrist index 0
    const wrist = lmToScene(landmarks[0]);
    // update threads: from wrist to each fingertip 4,8,12,16,20
    const tips = [4,8,12,16,20];
    for(let i=0;i<5;i++){
      const p = lmToScene(landmarks[tips[i]]);
      threadPositions[i*6+0]=wrist.x; threadPositions[i*6+1]=wrist.y; threadPositions[i*6+2]=wrist.z;
      threadPositions[i*6+3]=p.x; threadPositions[i*6+4]=p.y; threadPositions[i*6+5]=p.z;
    }
    threadGeom.attributes.position.needsUpdate = true;
    // hand skeleton lines
    for(let i=0;i<HAND_CONN.length;i++){
      const a = HAND_CONN[i][0], b = HAND_CONN[i][1];
      const pa = lmToScene(landmarks[a]);
      const pb = lmToScene(landmarks[b]);
      handLinePositions[i*6+0]=pa.x; handLinePositions[i*6+1]=pa.y; handLinePositions[i*6+2]=pa.z;
      handLinePositions[i*6+3]=pb.x; handLinePositions[i*6+4]=pb.y; handLinePositions[i*6+5]=pb.z;
    }
    handLineGeom.attributes.position.needsUpdate = true;

    // marker show at palm (use landmark 0)
    markerDetect.position.copy(wrist);
    markerDetect.visible = true;

    // detect OK sign (thumb tip close to index tip)
    const dThumbIndex = Math.hypot(landmarks[4].x-landmarks[8].x, landmarks[4].y-landmarks[8].y);
    const ok = dThumbIndex < 0.03; // threshold
    if(ok){ markerUnderstand.position.copy(lmToScene(landmarks[9])); markerUnderstand.visible=true; }
    else markerUnderstand.visible=false;
  }

  // Ø­Ø§Ù„ØªÙŠÙ†: ÙŠØ¯ Ù…ÙƒØªØ´ÙØ© Ø£Ùˆ Ù„Ø§
  hands.onResults((results)=>{
    const now = performance.now();
    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
      const lm = results.multiHandLandmarks[0];
      updateHandVisuals(lm);

      // Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø© ÙŠØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø´Ù‡Ø¯
      handX = (lm[8].x - 0.5) * window.innerWidth * 0.06;
      handY = -(lm[8].y - 0.5) * window.innerHeight * 0.045;

      // Ù‚ÙŠØ§Ø³ Ø§Ù„Ù‚Ø±ØµØ©: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø¥Ø¨Ù‡Ø§Ù… (4) ÙˆØ³Ø¨Ø§Ø¨Ø© (8)
      const dx = lm[4].x - lm[8].x; const dy = lm[4].y - lm[8].y;
      scale = Math.max(0.52, Math.sqrt(dx*dx + dy*dy) * 8);

      // Ø´ÙƒÙ„ Ø§Ù„Ù‚Ø¨Ø¶Ø©
      const isFist = (lm[12].y > lm[9].y);
      currentShape = isFist ? 'heart' : 'sphere';

      // V sign
      const indexUp = lm[8].y < lm[6].y;
      const middleUp = lm[12].y < lm[10].y;
      const ringUp = lm[16].y < lm[14].y;
      if(indexUp && middleUp && !ringUp && (now - lastColorTime > COOLDOWN)){
        colorMode = (colorMode + 1) % 3;
        lastColorTime = now; statusText.innerText='ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù„ÙˆÙ†';
      }

      // thumb up (Ø¨Ø³ÙŠØ·)
      const thumbUp = lm[4].y < lm[3].y;
      if(thumbUp && (now - lastBoostTime > 800)){
        lastBoostTime = now; rotSpeed = 0.02; setTimeout(()=>rotSpeed=0.002,500); statusText.innerText='Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†';
      }

      // rock: index & pinky up & middle down
      const pinkyUp = lm[20].y < lm[18].y;
      const rock = indexUp && pinkyUp && (lm[12].y > lm[10].y) && (now - lastExplosionTime > 900);
      if(rock){ lastExplosionTime = now; for(let i=0;i<COUNT;i++){ vel[i*3]+=(Math.random()-.5)*8; vel[i*3+1]+=(Math.random()-.5)*8; vel[i*3+2]+=(Math.random()-.5)*8; } statusText.innerText='ØªÙØ¬ÙŠØ±!'; }

      // open hand -> freeze
      const openHand = indexUp && middleUp && ringUp && pinkyUp;
      freeze = openHand; if(freeze) statusText.innerText='ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯';

      // wave detection
      if(!hands._wave) hands._wave = [];
      hands._wave.push(lm[8].x);
      if(hands._wave.length>8) hands._wave.shift();
      const minX=Math.min(...hands._wave), maxX=Math.max(...hands._wave);
      if(maxX - minX > 0.38 && (now - lastResetTime > 900)){ lastResetTime = now; for(let i=0;i<COUNT;i++){ pos[i*3]=(Math.random()-.5)*120; pos[i*3+1]=(Math.random()-.5)*120; pos[i*3+2]=(Math.random()-.5)*120; vel[i*3]=vel[i*3+1]=vel[i*3+2]=0; } statusText.innerText='Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·'; }

    } else { updateHandVisuals(null); statusText.innerText='Ù„Ù… ØªÙÙƒØªØ´Ù ÙŠØ¯ â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§'; }
  });

  // Face mesh (mouth open)
  let mouthOpen=false;
  faceMesh.onResults((results)=>{
    const now = performance.now();
    if(results.multiFaceLandmarks && results.multiFaceLandmarks.length>0){
      const fl = results.multiFaceLandmarks[0];
      // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù†Ù‚Ø§Ø· 13 (upper center) Ùˆ14 (lower center) Ø¥Ù† ÙˆØ¬Ø¯Øª
      const a = fl[13], b = fl[14];
      if(a && b){
        const d = Math.hypot(a.x-b.x, a.y-b.y);
        if(d > 0.035 && (now - lastMouthTime > 900)){
          lastMouthTime = now;
          mouthOpen = true;
          // Ù†Ø´Ø§Ø· Ø§Ù„Ø´Ø±Ø§Ø±: Ù†Ø¶ÙŠÙ Ø³Ø±Ø¹Ø§Øª Ù‚ÙˆÙŠØ© Ù„Ø¹Ø¯Ø¯ Ù…Ù† Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª Ø§Ù„Ù‚Ø±ÙŠØ¨Ø© Ù…Ù† Ø§Ù„ÙÙ…
          for(let i=0;i<COUNT/6;i++){
            const j = Math.floor(Math.random()*COUNT);
            vel[j*3] += (Math.random()-.5)*30;
            vel[j*3+1] += (Math.random()-.2)*45;
            vel[j*3+2] += (Math.random()-.5)*30;
          }
          statusText.innerText='ÙØªØ­ Ø§Ù„ÙÙ…: Ø´Ø±Ø§Ø±!';
          setTimeout(()=>{ mouthOpen=false; }, 600);
        }
      }
    }
  });

  // ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ + Mediapipe Camera
  startButton.onclick = async ()=>{
    overlay.style.display = 'none'; statusText.innerText='Ø¬Ø§Ø±ÙŠ Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...';
    try{
      const cameraHelper = new Camera(video, {
        onFrame: async ()=>{
          await hands.send({image: video});
          await faceMesh.send({image: video});
        }, width:640, height:480
      });
      await cameraHelper.start();
      try{ camPreview.srcObject = video.srcObject; await camPreview.play(); }catch(e){}
      statusText.innerText='ÙƒØ§Ù…ÙŠØ±Ø§ Ø´ØºÙ‘Ø§Ù„Ø© â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ ÙˆÙÙ…Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
      animate();
    }catch(err){ console.error('Camera error',err); statusText.innerText='Ø®Ø·Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: '+(err&&err.message?err.message:err); overlay.style.display='flex'; }
  };

  // animation loop
  let time = 0;
  function animate(){
    requestAnimationFrame(animate);
    if(!freeze) time += 0.012;

    const positions = geo.attributes.position.array;
    const colors = geo.attributes.color.array;

    for(let i=0;i<COUNT;i++){
      const i3 = i*3;
      // attractor
      let target = (currentShape==='heart') ? heart((i/COUNT)*Math.PI*2).multiplyScalar(scale*1.6) : sphere(i).multiplyScalar(scale*1.2);
      const noise = Math.sin(time + i) * 0.6;

      // apply velocities
      positions[i3] += vel[i3] * 0.02;
      positions[i3+1] += vel[i3+1] * 0.02;
      positions[i3+2] += vel[i3+2] * 0.02;

      // attraction towards shape + hand offset
      positions[i3] += (target.x + handX + noise - positions[i3]) * 0.09;
      positions[i3+1] += (target.y + handY + noise - positions[i3+1]) * 0.09;
      positions[i3+2] += (target.z - positions[i3+2]) * 0.085;

      // damping velocities
      vel[i3] *= 0.93; vel[i3+1] *= 0.93; vel[i3+2] *= 0.93;

      // colors
      if(colorMode===0){ colors[i3]=0.6; colors[i3+1]=0.6; colors[i3+2]=1; }
      else if(colorMode===1){ colors[i3]=1; colors[i3+1]=0.45; colors[i3+2]=0.5; }
      else { colors[i3]=0.35; colors[i3+1]=0.95; colors[i3+2]=0.6; }
    }

    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;

    // update hand visuals buffers
    handLineGeom.attributes.position.needsUpdate = true;
    threadGeom.attributes.position.needsUpdate = true;

    particles.rotation.y += rotSpeed;
    renderer.render(scene,camera);
  }

  window.addEventListener('resize',()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

</script></body>
</html>
