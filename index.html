<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù†Ø³Ø®Ø© Ù…ØµØ­Ø­Ø©</title>
<style>
  body{margin:0;overflow:hidden;background:#000;color:#fff;font-family:Segoe UI,Arial}
  canvas{display:block}
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;z-index:1000;flex-direction:column;gap:10px}
  button{padding:10px 22px;border-radius:999px;border:none;background:#ff4757;color:#fff;cursor:pointer;font-size:1rem}
  #status{position:fixed;bottom:12px;left:0;right:0;text-align:center;z-index:20}
  #legend{position:fixed;top:12px;left:12px;padding:10px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);border-radius:10px;z-index:30;max-width:260px;font-size:.9rem}
  #camBox{position:fixed;bottom:12px;right:12px;width:220px;height:160px;border-radius:12px;overflow:hidden;z-index:40;border:2px solid rgba(255,255,255,.12);background:#000}
  #camBox video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
</style>
</head>
<body>

<div id="overlay">
  <h2 style="margin:0">ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù…ÙØµÙ„Ù‘Ø­Ø©</h2>
  <div style="color:#ddd">Ø§Ø¶ØºØ· Ø§Ø¨Ø¯Ø£ ÙˆØ§Ø³Ù…Ø­ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (ÙŠÙØ¶Ù„ Chrome / localhost Ø£Ùˆ HTTPS)</div>
  <button id="startButton">Ø§Ø¨Ø¯Ø£</button>
</div>

<div id="status">Ø¬Ø§Ù‡Ø²</div>

<div id="legend">
  <b>ğŸ® Ø­Ø±ÙƒØ§Øª</b><br>
  ğŸ– Ø³Ø¨Ø§Ø¨Ø© â†’ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª<br>
  ğŸ¤ Ù‚Ø±ØµØ© â†’ ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ±<br>
  âœŒï¸ Ø¥ØµØ¨Ø¹ÙŠÙ† â†’ ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†<br>
  ğŸ‘ Ø¥Ø¨Ù‡Ø§Ù… Ù„ÙÙˆÙƒ â†’ Ø¯ÙØ¹Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†<br>
  ğŸ¤˜ Ø±ÙˆÙƒ â†’ ØªÙØ¬ÙŠØ± Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª<br>
  ğŸ– ÙŠØ¯ Ù…ÙØªÙˆØ­Ø© â†’ ØªØ¬Ù…ÙŠØ¯<br>
  ğŸ‘‹ ØªÙ„ÙˆÙŠØ­ â†’ Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·<br>
  ğŸ‘„ ÙØªØ­ Ø§Ù„ÙÙ… â†’ Ø´Ø±Ø§Ø± ÙŠØªÙ†Ø§Ø«Ø± Ø¨Ø¹ÙŠØ¯
</div>

<div id="camBox"><video id="camPreview" autoplay muted playsinline></video></div>

<!-- MediaPipe libs (non-module globals) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

// UI
const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const camPreview = document.getElementById('camPreview');

// Three setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 85;

// Particles
let COUNT = 1400; // Ø£Ù‚Ù„ Ù„Ø§Ù„ØªÙ‚Ø§Ø· Ø£ÙØ¶Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ø¶Ø¹ÙŠÙØ©
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const vel = new Float32Array(COUNT*3);
for(let i=0;i<COUNT;i++){
  positions[i*3] = (Math.random()-.5)*120;
  positions[i*3+1] = (Math.random()-.5)*120;
  positions[i*3+2] = (Math.random()-.5)*120;
  colors[i*3]=0.6; colors[i*3+1]=0.6; colors[i*3+2]=1;
  vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
const mat = new THREE.PointsMaterial({ size: 0.9, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending, map:sprite, depthWrite:false });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Hand visuals group
const handGroup = new THREE.Group();
scene.add(handGroup);

// THREADS: line segments from wrist to fingertips (5 segments)
const threadPositions = new Float32Array(5 * 2 * 3); // 5 fingers * 2 points * xyz
const threadGeom = new THREE.BufferGeometry();
threadGeom.setAttribute('position', new THREE.BufferAttribute(threadPositions,3));
const threadMat = new THREE.LineBasicMaterial({ color: 0x66ffff, transparent:true, opacity:0.9 });
const threadLines = new THREE.LineSegments(threadGeom, threadMat);
handGroup.add(threadLines);

// HAND SKELETON segments (use map of connections)
const HAND_CONN = [
  [0,1],[1,2],[2,3],[3,4],
  [0,5],[5,6],[6,7],[7,8],
  [5,9],[9,10],[10,11],[11,12],
  [9,13],[13,14],[14,15],[15,16],
  [13,17],[17,18],[18,19],[19,20],[0,17]
];
const handLinePositions = new Float32Array(HAND_CONN.length * 2 * 3);
const handLineGeom = new THREE.BufferGeometry();
handLineGeom.setAttribute('position', new THREE.BufferAttribute(handLinePositions,3));
const handLineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.9 });
const handLines = new THREE.LineSegments(handLineGeom, handLineMat);
handGroup.add(handLines);

// Markers (detect / understand)
const markerGeom = new THREE.SphereGeometry(2.6, 8, 6);
const markerDetectMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.95 });
const markerUnderstandMat = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent:true, opacity:0.95 });
const markerDetect = new THREE.Mesh(markerGeom, markerDetectMat);
const markerUnderstand = new THREE.Mesh(markerGeom, markerUnderstandMat);
markerDetect.visible = false; markerUnderstand.visible = false;
handGroup.add(markerDetect); handGroup.add(markerUnderstand);

// helpers: mapping landmarks -> scene coords
function lmToScene(lm){
  const x = (lm.x - 0.5) * window.innerWidth * 0.06;
  const y = -(lm.y - 0.5) * window.innerHeight * 0.045;
  const z = (lm.z || 0) * 40;
  return new THREE.Vector3(x,y,z);
}

// shapes
const heart = (t)=> new THREE.Vector3(
  16*Math.pow(Math.sin(t),3),
  13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t),
  0
);
const spherePoint = (i)=> {
  const phi = Math.acos(-1 + 2*i/COUNT);
  const th = Math.sqrt(COUNT * Math.PI) * phi;
  return new THREE.Vector3().setFromSphericalCoords(22, phi, th);
};

// state
let handX=0, handY=0, scale=1, rotSpeed=0.002, freeze=false;
let colorMode=0, currentShape='sphere';
const cooldown = { color:0, explosion:0, boost:0, reset:0, mouth:0 };

// MediaPipe video (hidden)
const video = document.createElement('video');
video.autoplay = true; video.muted = true; video.playsInline = true; video.style.display = 'none';
document.body.appendChild(video);

// MediaPipe Hands
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.55, minTrackingConfidence:0.55 });

// MediaPipe FaceMesh (for mouth)
const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });

// debug helper (console)
function dbg(...a){ /* console.log(...a); */ }

// update visuals (threads + skeleton + markers)
function updateHandVisuals(landmarks){
  if(!landmarks){ threadLines.visible=false; handLines.visible=false; markerDetect.visible=false; markerUnderstand.visible=false; return; }
  threadLines.visible = true; handLines.visible = true;

  const wrist = lmToScene(landmarks[0]);

  // threads: pairs (wrist -> fingertip)
  const tips = [4,8,12,16,20];
  for(let i=0;i<5;i++){
    const p = lmToScene(landmarks[tips[i]]);
    const base = i*6;
    threadPositions[base+0] = wrist.x;
    threadPositions[base+1] = wrist.y;
    threadPositions[base+2] = wrist.z;
    threadPositions[base+3] = p.x;
    threadPositions[base+4] = p.y;
    threadPositions[base+5] = p.z;
  }
  threadGeom.attributes.position.needsUpdate = true;

  // skeleton lines using HAND_CONN
  for(let i=0;i<HAND_CONN.length;i++){
    const a = HAND_CONN[i][0], b = HAND_CONN[i][1];
    const pa = lmToScene(landmarks[a]);
    const pb = lmToScene(landmarks[b]);
    const off = i*6;
    handLinePositions[off+0]=pa.x; handLinePositions[off+1]=pa.y; handLinePositions[off+2]=pa.z;
    handLinePositions[off+3]=pb.x; handLinePositions[off+4]=pb.y; handLinePositions[off+5]=pb.z;
  }
  handLineGeom.attributes.position.needsUpdate = true;

  // show marker at palm/wrist
  markerDetect.position.copy(wrist);
  markerDetect.visible = true;

  // detect "OK"/understand: thumb near index
  const dThumbIndex = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
  if(dThumbIndex < 0.03){
    markerUnderstand.position.copy(lmToScene(landmarks[9]));
    markerUnderstand.visible = true;
  } else markerUnderstand.visible = false;
}

// HANDS results
hands.onResults((res)=>{
  const now = performance.now();
  if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0){
    const lm = res.multiHandLandmarks[0];
    updateHandVisuals(lm);

    // pointer pos (index tip)
    handX = (lm[8].x - 0.5) * window.innerWidth * 0.06;
    handY = -(lm[8].y - 0.5) * window.innerHeight * 0.045;

    // pinch scale (thumb tip vs index tip)
    const dx = lm[4].x - lm[8].x, dy = lm[4].y - lm[8].y;
    scale = Math.max(0.5, Math.sqrt(dx*dx + dy*dy) * 8);

    // fist detection -> heart
    const isFist = (lm[12].y > lm[9].y);
    currentShape = isFist ? 'heart' : 'sphere';

    // V sign (index & middle up, ring down) -> change color (cooldown)
    const indexUp = lm[8].y < lm[6].y;
    const middleUp = lm[12].y < lm[10].y;
    const ringUp = lm[16].y < lm[14].y;
    if(indexUp && middleUp && !ringUp && now - cooldown.color > 700){
      colorMode = (colorMode + 1) % 3;
      cooldown.color = now;
      statusText.innerText = 'ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù„ÙˆÙ†';
    }

    // thumb up -> boost rotation
    const thumbUp = lm[4].y < lm[3].y;
    if(thumbUp && now - cooldown.boost > 800){
      cooldown.boost = now;
      rotSpeed = 0.02;
      setTimeout(()=> rotSpeed = 0.002, 550);
      statusText.innerText = 'Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†';
    }

    // rock: index & pinky up & middle down -> explosion
    const pinkyUp = lm[20].y < lm[18].y;
    const rock = indexUp && pinkyUp && (lm[12].y > lm[10].y);
    if(rock && now - cooldown.explosion > 900){
      cooldown.explosion = now;
      for(let i=0;i<COUNT;i++){
        vel[i*3] += (Math.random()-.5) * 8;
        vel[i*3+1] += (Math.random()-.5) * 8;
        vel[i*3+2] += (Math.random()-.5) * 8;
      }
      statusText.innerText = 'ØªÙØ¬ÙŠØ±!';
    }

    // open hand -> freeze
    const openHand = indexUp && middleUp && ringUp && pinkyUp;
    freeze = openHand;
    if(freeze) statusText.innerText = 'ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯';

    // wave detection for reset: track X history in res object (simple ring)
    if(!hands._wave) hands._wave = [];
    hands._wave.push(lm[8].x);
    if(hands._wave.length > 10) hands._wave.shift();
    const minX = Math.min(...hands._wave), maxX = Math.max(...hands._wave);
    if(maxX - minX > 0.36 && performance.now() - cooldown.reset > 900){
      cooldown.reset = performance.now();
      for(let i=0;i<COUNT;i++){
        positions[i*3] = (Math.random()-.5)*120;
        positions[i*3+1] = (Math.random()-.5)*120;
        positions[i*3+2] = (Math.random()-.5)*120;
        vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
      }
      statusText.innerText = 'Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·';
    }

  } else {
    updateHandVisuals(null);
    statusText.innerText = 'Ù„Ù… ØªÙÙƒØªØ´Ù ÙŠØ¯ â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
  }
});

// FaceMesh results (mouth open => spark)
faceMesh.onResults((res)=>{
  const now = performance.now();
  if(res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0){
    const fl = res.multiFaceLandmarks[0];
    // common indices around lips: use upper center (13) and lower center (14) as approximate
    const a = fl[13], b = fl[14];
    if(a && b){
      const d = Math.hypot(a.x - b.x, a.y - b.y);
      if(d > 0.037 && now - cooldown.mouth > 900){
        cooldown.mouth = now;
        // push some particles outward as "sparks"
        for(let k=0;k<Math.floor(COUNT/6);k++){
          const j = Math.floor(Math.random()*COUNT);
          vel[j*3] += (Math.random()-.5)*30;
          vel[j*3+1] += Math.random()*45; // more upward
          vel[j*3+2] += (Math.random()-.5)*30;
        }
        statusText.innerText = 'ÙØªØ­ Ø§Ù„ÙÙ…: Ø´Ø±Ø§Ø±!';
      }
    }
  }
});

// camera utils: create Camera and start sending frames to mediapipe
startButton.onclick = async ()=>{
  overlay.style.display = 'none';
  statusText.innerText = 'Ø¬Ø§Ø±ÙŠ Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...';
  try{
    const cam = new Camera(video, {
      onFrame: async ()=>{
        await hands.send({image: video});
        await faceMesh.send({image: video});
      },
      width: 640, height: 480
    });
    await cam.start();

    // show preview (video.srcObject is set by Camera)
    try{ camPreview.srcObject = video.srcObject; await camPreview.play(); }catch(e){ /* autoplay restrictions */ }

    statusText.innerText = 'ÙƒØ§Ù…ÙŠØ±Ø§ Ø´ØºÙ‘Ø§Ù„Ø© â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ ÙˆÙÙ…Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
    animate();
  }catch(err){
    console.error('Camera error', err);
    statusText.innerText = 'Ø®Ø·Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: '+(err && err.message?err.message:err);
    overlay.style.display = 'flex';
  }
};

// animation loop
let time = 0;
function animate(){
  requestAnimationFrame(animate);
  if(!freeze) time += 0.012;

  // update particles
  for(let i=0;i<COUNT;i++){
    const i3 = i*3;

    // velocity applied
    positions[i3] += vel[i3]*0.02;
    positions[i3+1] += vel[i3+1]*0.02;
    positions[i3+2] += vel[i3+2]*0.02;

    // attractor target
    const target = (currentShape === 'heart')
      ? heart((i/COUNT)*Math.PI*2).multiplyScalar(scale*1.6)
      : spherePoint(i).multiplyScalar(scale*1.2);

    const noise = Math.sin(time + i) * 0.6;
    positions[i3] += (target.x + handX + noise - positions[i3]) * 0.09;
    positions[i3+1] += (target.y + handY + noise - positions[i3+1]) * 0.09;
    positions[i3+2] += (target.z - positions[i3+2]) * 0.085;

    // damping
    vel[i3] *= 0.93; vel[i3+1] *= 0.93; vel[i3+2] *= 0.93;

    // color modes
    if(colorMode===0){ colors[i3]=0.6; colors[i3+1]=0.6; colors[i3+2]=1; }
    else if(colorMode===1){ colors[i3]=1; colors[i3+1]=0.45; colors[i3+2]=0.5; }
    else { colors[i3]=0.35; colors[i3+1]=0.95; colors[i3+2]=0.6; }
  }

  geo.attributes.position.needsUpdate = true;
  geo.attributes.color.needsUpdate = true;
  threadGeom.attributes.position.needsUpdate = true;
  handLineGeom.attributes.position.needsUpdate = true;

  particles.rotation.y += rotSpeed;
  renderer.render(scene, camera);
}

// resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
