<!doctype html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>AR Gesture V7 - Zoom & Control</title>
    <style>
        :root { --neon: #00ffcc; --bg: #000; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer {
            position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.85);
            color: white; padding: 20px; border-radius: 15px; border: 1px solid var(--neon);
            z-index: 100; pointer-events: none; width: 280px;
        }
        #ui-layer h3 { margin: 0 0 10px 0; color: var(--neon); text-align: center; border-bottom: 1px solid #333; }
        .gesture-item { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; }
        .active-status { color: #ff0055; font-weight: bold; text-align: center; margin-top: 10px; }

        #camPreview { position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0.3; }
        canvas { position: fixed; inset: 0; z-index: 10; }
        
        #overlay { position: fixed; inset: 0; background: #000; display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; color: white; }
        button { padding: 20px 60px; border-radius: 50px; border: 2px solid var(--neon); background: transparent; color: var(--neon); cursor: pointer; font-size: 1.5rem; transition: 0.3s; }
        button:hover { background: var(--neon); color: black; box-shadow: 0 0 40px var(--neon); }
        
        #status-bar { position: fixed; bottom: 30px; width: 100%; text-align: center; color: var(--neon); z-index: 100; font-size: 1.1rem; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3>ğŸ® Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ§Øª V7</h3>
    <div class="gesture-item"><span>ØªÙ‚Ø±ÙŠØ¨/ØªØ¨Ø¹ÙŠØ¯:</span> <span>Ø³ÙˆÙŠ ğŸ¤</span></div>
    <div class="gesture-item"><span>Ù†Ø«Ø± (Ø§Ù†ÙØ¬Ø§Ø±):</span> <span>Ø³ÙˆÙŠ âœŒï¸</span></div>
    <div class="gesture-item"><span>Ø³Ø­Ø¨ (Ù…ØºÙ†Ø§Ø·ÙŠØ³):</span> <span>Ø³ÙˆÙŠ âœŠ</span></div>
    <div id="current-gesture" class="active-status">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙŠØ¯...</div>
</div>

<div id="overlay">
    <h1>AR ENGINE <span style="color:var(--neon)">V7</span></h1>
    <p style="opacity: 0.6; margin-bottom: 30px;">Ù†Ø¸Ø§Ù… ØªØªØ¨Ø¹ Ø§Ù„ÙŠØ¯ Ø§Ù„Ø°ÙƒÙŠ Ù…Ø¹ Ù…ÙŠØ²Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ¨</p>
    <button id="startButton">ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…</button>
</div>

<div id="status-bar">ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</div>
<video id="camPreview" playsinline muted></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const videoEl = document.getElementById('camPreview');
const statusText = document.getElementById('status-bar');
const gestureText = document.getElementById('current-gesture');

// --- Ø¥Ø¹Ø¯Ø§Ø¯ Three.js ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ø¹ÙŠØ¯Ø© Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ‚Ø±ÙŠØ¨
camera.position.z = 150;

// Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ (Ø¹Ù‚Ø¯Ø© Ù‡Ù†Ø¯Ø³ÙŠØ© Ù…ØªØ·ÙˆØ±Ø©)
const geometry = new THREE.TorusKnotGeometry(12, 4, 120, 20);
const material = new THREE.MeshBasicMaterial({ color: 0x00ffcc, wireframe: true, transparent: true, opacity: 0.4 });
const mainMesh = new THREE.Mesh(geometry, material);
scene.add(mainMesh);

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
const COUNT = 2000;
const posArr = new Float32Array(COUNT * 3);
for(let i=0; i<COUNT*3; i++) posArr[i] = (Math.random()-0.5)*400;
const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
const particleMat = new THREE.PointsMaterial({ size: 1.2, color: 0x00ffcc, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

let targetPos = new THREE.Vector3(0,0,0);
let targetZ = 0; // Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ ÙˆØ§Ù„ØªØ¨Ø¹ÙŠØ¯
let mode = "follow";

// --- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥ÙŠÙ…Ø§Ø¡Ø§Øª ---
function analyzeHand(hand) {
    const thumb = hand[4], index = hand[8], middle = hand[12], ring = hand[16], pinky = hand[20];
    
    // 1. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ù„Ù‚Ø±Øµ ğŸ¤ (Zoom)
    const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
    
    // 2. ÙƒØ´Ù Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù†ØµØ± âœŒï¸
    const isPeace = (index.y < hand[6].y && middle.y < hand[10].y && ring.y > hand[14].y);
    
    // 3. ÙƒØ´Ù Ø§Ù„Ù‚Ø¨Ø¶Ø© âœŠ
    const isFist = (index.y > hand[6].y && middle.y > hand[10].y && ring.y > hand[14].y);

    if (pinchDist < 0.04) return "PINCH";
    if (isPeace) return "PEACE";
    if (isFist) return "FIST";
    return "OPEN";
}

// --- MediaPipe Holistic ---
const holistic = new window.Holistic({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
});

holistic.setOptions({ modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

holistic.onResults((res) => {
    if (res.rightHandLandmarks) {
        const hand = res.rightHandLandmarks;
        const gesture = analyzeHand(hand);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù (X, Y)
        targetPos.x = -(hand[9].x - 0.5) * 250;
        targetPos.y = -(hand[9].y - 0.5) * 180;

        if (gesture === "PINCH") {
            mode = "zoom";
            // Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø­ÙˆØ± Z (Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙˆÙ‚Ø¹ Y ÙƒØ¨Ø¯ÙŠÙ„ Ù„Ù„Ø³Ù‡ÙˆÙ„Ø©)
            targetZ = (0.5 - hand[9].z) * 500; 
            gestureText.innerText = "Ø¥Ù…Ø³Ø§Ùƒ ÙˆØªÙ‚Ø±ÙŠØ¨ ğŸ¤";
            particleMat.color.set(0xffff00);
        } else if (gesture === "PEACE") {
            mode = "explode";
            gestureText.innerText = "Ø§Ù†ÙØ¬Ø§Ø± Ø¬Ø²ÙŠØ¦Ø§Øª âœŒï¸";
            particleMat.color.set(0xff0055);
        } else if (gesture === "FIST") {
            mode = "attract";
            gestureText.innerText = "Ø³Ø­Ø¨ Ù…ØºÙ†Ø§Ø·ÙŠØ³ÙŠ âœŠ";
            particleMat.color.set(0xaa00ff);
        } else {
            mode = "follow";
            gestureText.innerText = "ØªØªØ¨Ø¹ Ø­Ø± ğŸ–ï¸";
            particleMat.color.set(0x00ffcc);
        }
    }
});

// --- Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ­Ø±ÙŠÙƒ ÙˆØ§Ù„ÙÙŠØ²ÙŠØ§Ø¡ ---
function animate() {
    requestAnimationFrame(animate);
    
    // ØªÙ†Ø¹ÙŠÙ… Ø­Ø±ÙƒØ© Ø§Ù„Ø´ÙƒÙ„
    mainMesh.position.x += (targetPos.x - mainMesh.position.x) * 0.1;
    mainMesh.position.y += (targetPos.y - mainMesh.position.y) * 0.1;
    
    if (mode === "zoom") {
        mainMesh.position.z += (targetZ - mainMesh.position.z) * 0.1;
    }

    mainMesh.rotation.y += 0.01;

    const positions = particleGeo.attributes.position.array;
    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;
        const dx = mainMesh.position.x - positions[i3];
        const dy = mainMesh.position.y - positions[i3+1];
        const dz = mainMesh.position.z - positions[i3+2];
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

        if (mode === "explode") {
            positions[i3] -= (dx/dist) * 8;
            positions[i3+1] -= (dy/dist) * 8;
            positions[i3+2] -= (dz/dist) * 8;
        } else if (mode === "attract") {
            positions[i3] += dx * 0.06;
            positions[i3+1] += dy * 0.06;
            positions[i3+2] += dz * 0.06;
        } else {
            // ØªØªØ¨Ø¹ Ù‡Ø§Ø¯Ø¦
            positions[i3] += (dx * 0.02) + (Math.random()-0.5)*1.5;
            positions[i3+1] += (dy * 0.02) + (Math.random()-0.5)*1.5;
            positions[i3+2] += (dz * 0.02) + (Math.random()-0.5)*1.5;
        }

        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª Ø¥Ø°Ø§ Ø·Ø§Ø±Øª Ø¨Ø¹ÙŠØ¯Ø§Ù‹
        if (dist > 500) {
            positions[i3] = mainMesh.position.x + (Math.random()-0.5)*100;
            positions[i3+1] = mainMesh.position.y + (Math.random()-0.5)*100;
            positions[i3+2] = mainMesh.position.z + (Math.random()-0.5)*100;
        }
    }
    
    particleGeo.attributes.position.needsUpdate = true;
    renderer.render(scene, camera);
}

// --- Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ ---
document.getElementById('startButton').onclick = () => {
    document.getElementById('overlay').style.display = 'none';
    const cameraHelper = new window.Camera(videoEl, {
        onFrame: async () => { await holistic.send({ image: videoEl }); },
        width: 1280, height: 720
    });
    cameraHelper.start().then(() => {
        statusText.innerText = "Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ - Ø¬Ø±Ø¨ Ø­Ø±ÙƒØ© ğŸ¤ Ù„Ù„ØªÙ‚Ø±ÙŠØ¨";
        animate();
    });
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
