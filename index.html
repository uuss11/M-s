<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AR Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„ - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  #camPreview { position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
  canvas { position: fixed; inset: 0; z-index: 10; pointer-events: none; }
  #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; color: white; }
  button { padding: 15px 40px; border-radius: 50px; border: none; background: #00d1b2; color: white; cursor: pointer; font-size: 1.2rem; box-shadow: 0 0 20px #00d1b2; }
  #status { position: fixed; top: 20px; width: 100%; text-align: center; color: #00ff88; z-index: 100; font-weight: bold; text-shadow: 0 0 5px #000; }
  #legend { position: fixed; bottom: 20px; left: 20px; padding: 15px; background: rgba(0,0,0,0.6); color: white; border-radius: 15px; z-index: 100; font-size: 0.8rem; border-left: 4px solid #ff4757; }
  #voiceIndicator { position: fixed; top: 50px; left: 20px; color: #ff4757; font-weight: bold; z-index: 100; }
</style>
</head>
<body>

<div id="overlay">
  <h1>Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„ØµÙˆØªÙŠ AR V4</h1>
  <p>ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¬Ø³Ù…ØŒ Ø§Ù„Ø±Ø³Ù…ØŒ ÙˆØ§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØµÙˆØªÙŠØ© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©</p>
  <button id="startButton">ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„</button>
</div>

<div id="status">Ø¨Ø§Ù†ØªØ¸Ø§Ø± ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...</div>
<div id="voiceIndicator">ğŸ¤ Ù…Ø³ØªØ¹Ø¯ Ù„Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØµÙˆØªÙŠØ©...</div>

<div id="legend">
  ğŸ—£ï¸ <b>ØµÙˆØª:</b> "Ø£Ø­Ù…Ø±"ØŒ "Ø£Ø²Ø±Ù‚"ØŒ "Ø§Ù†ÙØ¬Ø§Ø±"ØŒ "Ù‚Ù„Ø¨".<br>
  ğŸ¤ <b>Ø³Ø­Ø¨:</b> Ø§Ù‚Ø±Øµ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø© ÙˆØ§Ù„Ø¥Ø¨Ù‡Ø§Ù… Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´ÙƒÙ„.<br>
  âœŒï¸ <b>Ø±Ø³Ù…:</b> Ø³Ø¨Ø§Ø¨Ø© + ÙˆØ³Ø·Ù‰ Ù„Ù„Ø±Ø³Ù… ÙÙŠ Ø§Ù„Ù‡ÙˆØ§Ø¡.<br>
  ğŸ‘ <b>Ù…Ø³Ø­:</b> Ø§Ø±ÙØ¹ Ø§Ù„Ø¥Ø¨Ù‡Ø§Ù… Ù„Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù….
</div>

<video id="camPreview" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 100;

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
const COUNT = 2000;
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);
const vel = new Float32Array(COUNT * 3);
for(let i=0; i<COUNT*3; i++) {
    positions[i] = (Math.random()-0.5)*200;
    vel[i] = 0;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
const mat = new THREE.PointsMaterial({ size: 0.9, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø³Ù…
const drawPoints = [];
const drawGeo = new THREE.BufferGeometry();
const drawMat = new THREE.PointsMaterial({ size: 1.5, color: 0x00ffff, transparent: true, opacity: 0.8 });
const drawing = new THREE.Points(drawGeo, drawMat);
scene.add(drawing);

// Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¬Ø³Ù…
const bodyLinesGeo = new THREE.BufferGeometry();
const bodyLines = new THREE.LineSegments(bodyLinesGeo, new THREE.LineBasicMaterial({ color: 0x00ff88, opacity: 0.5, transparent: true }));
scene.add(bodyLines);

const fingerLight = new THREE.PointLight(0x00ffff, 2, 60);
scene.add(fingerLight);

// Ø§Ù„Ø­Ø§Ù„Ø©
let targetPos = new THREE.Vector3(0,0,0);
let scaleVal = 1;
let isDragging = false;
let currentShape = 'sphere';
let particleColor = new THREE.Color(0x00ccff);

// --- Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„ØµÙˆØªÙŠ ---
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
if (SpeechRecognition) {
    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.lang = 'ar-SA'; // ÙŠØ¯Ø¹Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©

    recognition.onresult = (event) => {
        const command = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
        console.log("Command:", command);
        
        if (command.includes("Ø£Ø­Ù…Ø±") || command.includes("red")) {
            particleColor.set(0xff0000);
            statusText.innerText = "ØµÙˆØª: ØªØ­ÙˆÙŠÙ„ Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø­Ù…Ø± ğŸ”´";
        } else if (command.includes("Ø£Ø²Ø±Ù‚") || command.includes("blue")) {
            particleColor.set(0x00ccff);
            statusText.innerText = "ØµÙˆØª: ØªØ­ÙˆÙŠÙ„ Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø²Ø±Ù‚ ğŸ”µ";
        } else if (command.includes("Ø£Ø®Ø¶Ø±") || command.includes("green")) {
            particleColor.set(0x00ff88);
            statusText.innerText = "ØµÙˆØª: ØªØ­ÙˆÙŠÙ„ Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø®Ø¶Ø± ğŸŸ¢";
        } else if (command.includes("Ø§Ù†ÙØ¬Ø§Ø±") || command.includes("explode")) {
            statusText.innerText = "ØµÙˆØª: ØªÙØ¬ÙŠØ± Ø§Ù„Ø·Ø§Ù‚Ø©! ğŸ’¥";
            for(let i=0; i<COUNT*3; i++) vel[i] += (Math.random()-0.5)*80;
        } else if (command.includes("Ù‚Ù„Ø¨") || command.includes("heart")) {
            currentShape = 'heart';
            statusText.innerText = "ØµÙˆØª: ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø¨ â¤ï¸";
        } else if (command.includes("ÙƒØ±Ø©") || command.includes("circle")) {
            currentShape = 'sphere';
            statusText.innerText = "ØµÙˆØª: Ø¹ÙˆØ¯Ø© Ù„Ø´ÙƒÙ„ Ø§Ù„ÙƒØ±Ø© âšª";
        }
    };
    recognition.start();
}

function lmToScene(lm) {
    if(!lm) return new THREE.Vector3(0,0,0);
    return new THREE.Vector3(-(lm.x - 0.5) * 130 * (window.innerWidth/window.innerHeight), -(lm.y - 0.5) * 100, -lm.z * 50);
}

const holistic = new Holistic({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}` });
holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

holistic.onResults((res) => {
    const allPoints = [];
    if(res.poseLandmarks) {
        const poseConn = [[11,12],[12,24],[24,23],[23,11],[11,13],[13,15],[12,14],[14,16]];
        poseConn.forEach(([a,b]) => {
            allPoints.push(lmToScene(res.poseLandmarks[a]), lmToScene(res.poseLandmarks[b]));
        });
        const dist = Math.abs(res.poseLandmarks[11].x - res.poseLandmarks[12].x);
        scaleVal = dist * 6;
    }

    if(res.rightHandLandmarks) {
        const h = res.rightHandLandmarks;
        const index = lmToScene(h[8]), thumb = lmToScene(h[4]), middle = lmToScene(h[12]);

        if(index.distanceTo(thumb) < 5) {
            isDragging = true; targetPos.copy(index);
        } else { isDragging = false; }

        if(index.distanceTo(middle) < 4 && h[8].y < h[6].y) {
            drawPoints.push(index.x, index.y, index.z);
            if(drawPoints.length > 2000) drawPoints.splice(0,3);
            drawGeo.setAttribute('position', new THREE.Float32BufferAttribute(drawPoints, 3));
        }
        if(h[4].y < h[3].y && h[8].y > h[6].y) {
            drawPoints.length = 0;
            drawGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
        }
        fingerLight.position.copy(index);
    }
    bodyLinesGeo.setFromPoints(allPoints);
});

const heartFn = (t) => new THREE.Vector3(16*Math.pow(Math.sin(t),3)/1.5, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))/1.5, 0);

function animate() {
    requestAnimationFrame(animate);
    const posAttr = geo.attributes.position;
    const colAttr = geo.attributes.color;
    const time = Date.now() * 0.002;

    for (let i = 0; i < COUNT; i++) {
        positions[i*3] += vel[i*3] * 0.05;
        positions[i*3+1] += vel[i*3+1] * 0.05;
        positions[i*3+2] += vel[i*3+2] * 0.05;

        let target;
        if (currentShape === 'heart') {
            target = heartFn((i/COUNT)*Math.PI*2).multiplyScalar(scaleVal*1.5);
        } else {
            const phi = Math.acos(-1 + 2*i/COUNT);
            const th = Math.sqrt(COUNT*Math.PI)*phi;
            target = new THREE.Vector3().setFromSphericalCoords(20 * scaleVal, phi, th);
        }

        positions[i*3] += (target.x + targetPos.x - positions[i*3]) * 0.08;
        positions[i*3+1] += (target.y + targetPos.y - positions[i*3+1]) * 0.08;
        positions[i*3+2] += (target.z + targetPos.z - positions[i*3+2]) * 0.08;

        vel[i*3] *= 0.92; vel[i*3+1] *= 0.92; vel[i*3+2] *= 0.92;
        posAttr.setXYZ(i, positions[i*3], positions[i*3+1], positions[i*3+2]);
        
        colAttr.setXYZ(i, particleColor.r, particleColor.g, particleColor.b);
    }

    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    renderer.render(scene, camera);
}

startButton.onclick = async () => {
    overlay.style.display = 'none';
    const cameraHelper = new Camera(videoEl, {
        onFrame: async () => { await holistic.send({ image: videoEl }); },
        width: 1280, height: 720
    });
    cameraHelper.start();
    animate();
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
