<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù†Ø³Ø®Ø© Ù…ÙØµØ­Ù‘Ø­Ø© ÙˆÙ…Ø¨Ø§Ø´Ø±Ø©</title>
<style>
  body{margin:0;overflow:hidden;background:#000;color:#fff;font-family:Segoe UI,Arial}
  canvas{display:block}
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;z-index:1000;flex-direction:column;gap:10px}
  button{padding:10px 22px;border-radius:999px;border:none;background:#ff4757;color:#fff;cursor:pointer;font-size:1rem}
  #status{position:fixed;bottom:12px;left:0;right:0;text-align:center;z-index:40}
  #legend{position:fixed;top:12px;left:12px;padding:10px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);border-radius:10px;z-index:40;max-width:300px;font-size:.9rem}
  #camBox{position:fixed;bottom:12px;right:12px;width:240px;height:170px;border-radius:12px;overflow:hidden;z-index:50;border:2px solid rgba(255,255,255,.12);background:#000}
  #camBox video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
</style>
</head>
<body>

<div id="overlay">
  <h2 style="margin:0">ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ â€” Ù†Ø³Ø®Ø© Ù…ÙØµØ­Ù‘Ø­Ø©</h2>
  <div style="color:#ddd">Ø§Ø¶ØºØ· Ø§Ø¨Ø¯Ø£ ÙˆØ§Ø³Ù…Ø­ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Chrome / localhost Ø£Ùˆ HTTPS)</div>
  <button id="startButton">Ø§Ø¨Ø¯Ø£</button>
</div>

<div id="status">Ø¬Ø§Ù‡Ø²</div>

<div id="legend">
  <b>ğŸ® Ø§Ù„Ø­Ø±ÙƒØ§Øª</b><br>
  ğŸ– Ø³Ø¨Ø§Ø¨Ø© â†’ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª<br>
  ğŸ¤ Ù‚Ø±ØµØ© â†’ ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ±<br>
  âœŒï¸ Ø¥ØµØ¨Ø¹ÙŠÙ† â†’ ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†<br>
  ğŸ‘ Ø¥Ø¨Ù‡Ø§Ù… Ù„ÙÙˆÙƒ â†’ Ø¯ÙØ¹Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†<br>
  ğŸ¤˜ Ø±ÙˆÙƒ â†’ ØªÙØ¬ÙŠØ± Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª<br>
  ğŸ– ÙŠØ¯ Ù…ÙØªÙˆØ­Ø© â†’ ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯<br>
  ğŸ‘‹ ØªÙ„ÙˆÙŠØ­ â†’ Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„Ù…Ø´Ù‡Ø¯<br>
  ğŸ‘„ ÙØªØ­ Ø§Ù„ÙÙ… â†’ Ø´Ø±Ø§Ø± ÙŠØªÙ†Ø§Ø«Ø± Ø¨Ø¹ÙŠØ¯
</div>

<div id="camBox"><video id="camPreview" autoplay muted playsinline></video></div>

<!-- MediaPipe libs -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

// UI
const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const camPreview = document.getElementById('camPreview');

// Three setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 85;

// Particles (reduced count for reliability)
const COUNT = 1300;
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const vel = new Float32Array(COUNT*3);
for(let i=0;i<COUNT;i++){
  positions[i*3] = (Math.random()-.5)*120;
  positions[i*3+1] = (Math.random()-.5)*120;
  positions[i*3+2] = (Math.random()-.5)*120;
  colors[i*3]=0.6; colors[i*3+1]=0.6; colors[i*3+2]=1;
  vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
const mat = new THREE.PointsMaterial({ size: 0.9, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending, map:sprite, depthWrite:false });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Hand visuals group
const handGroup = new THREE.Group();
scene.add(handGroup);

// THREADS: wrist->fingertips lines (5 segments)
const threadPositions = new Float32Array(5 * 2 * 3); // 30 values
const threadGeom = new THREE.BufferGeometry();
threadGeom.setAttribute('position', new THREE.BufferAttribute(threadPositions,3));
const threadMat = new THREE.LineBasicMaterial({ color: 0x66ffff, transparent:true, opacity:0.95 });
const threadLines = new THREE.LineSegments(threadGeom, threadMat);
handGroup.add(threadLines);

// HAND SKELETON
const HAND_CONN = [
  [0,1],[1,2],[2,3],[3,4],
  [0,5],[5,6],[6,7],[7,8],
  [5,9],[9,10],[10,11],[11,12],
  [9,13],[13,14],[14,15],[15,16],
  [13,17],[17,18],[18,19],[19,20],[0,17]
];
const handLinePositions = new Float32Array(HAND_CONN.length * 2 * 3);
const handLineGeom = new THREE.BufferGeometry();
handLineGeom.setAttribute('position', new THREE.BufferAttribute(handLinePositions,3));
const handLineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.95 });
const handLines = new THREE.LineSegments(handLineGeom, handLineMat);
handGroup.add(handLines);

// Markers
const markerGeom = new THREE.SphereGeometry(2.6, 8, 6);
const markerDetectMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent:true, opacity:0.95 });
const markerUnderstandMat = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent:true, opacity:0.95 });
const markerDetect = new THREE.Mesh(markerGeom, markerDetectMat);
const markerUnderstand = new THREE.Mesh(markerGeom, markerUnderstandMat);
markerDetect.visible = false; markerUnderstand.visible = false;
handGroup.add(markerDetect); handGroup.add(markerUnderstand);

// helpers
function lmToScene(lm){
  const x = (lm.x - 0.5) * window.innerWidth * 0.06;
  const y = -(lm.y - 0.5) * window.innerHeight * 0.045;
  const z = (lm.z || 0) * 40;
  return new THREE.Vector3(x,y,z);
}

const heart=(t)=> new THREE.Vector3(16*Math.pow(Math.sin(t),3),13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t),0);
const spherePoint=(i)=>{ const phi=Math.acos(-1 + 2*i/COUNT); const th=Math.sqrt(COUNT*Math.PI)*phi; return new THREE.Vector3().setFromSphericalCoords(22,phi,th); };

// state
let handX=0, handY=0, scaleVal=1, rotSpeed=0.002, freeze=false;
let colorMode=0, currentShape='sphere';
const cooldown = { color:0, explosion:0, boost:0, reset:0, mouth:0 };

// MediaPipe: use the visible video element as the camera source
const videoEl = camPreview; // pass this directly to Camera

// Hands and FaceMesh instances (global constructors provided by included scripts)
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.55, minTrackingConfidence:0.55 });

const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });

// update hand visuals
function updateHandVisuals(landmarks){
  if(!landmarks){ threadLines.visible=false; handLines.visible=false; markerDetect.visible=false; markerUnderstand.visible=false; return; }
  threadLines.visible=true; handLines.visible=true;
  const wrist = lmToScene(landmarks[0]);

  // threads (wrist->tips 4,8,12,16,20)
  const tips = [4,8,12,16,20];
  for(let i=0;i<5;i++){
    const p = lmToScene(landmarks[tips[i]]);
    const base = i*6;
    threadPositions[base+0]=wrist.x; threadPositions[base+1]=wrist.y; threadPositions[base+2]=wrist.z;
    threadPositions[base+3]=p.x; threadPositions[base+4]=p.y; threadPositions[base+5]=p.z;
  }
  threadGeom.attributes.position.needsUpdate = true;

  // skeleton lines
  for(let i=0;i<HAND_CONN.length;i++){
    const a=HAND_CONN[i][0], b=HAND_CONN[i][1];
    const pa = lmToScene(landmarks[a]), pb = lmToScene(landmarks[b]);
    const off = i*6;
    handLinePositions[off+0]=pa.x; handLinePositions[off+1]=pa.y; handLinePositions[off+2]=pa.z;
    handLinePositions[off+3]=pb.x; handLinePositions[off+4]=pb.y; handLinePositions[off+5]=pb.z;
  }
  handLineGeom.attributes.position.needsUpdate = true;

  // marker at wrist
  markerDetect.position.copy(wrist); markerDetect.visible=true;

  // OK detection (thumb near index)
  const dThumbIndex = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
  if(dThumbIndex < 0.03){ markerUnderstand.position.copy(lmToScene(landmarks[9])); markerUnderstand.visible=true; }
  else markerUnderstand.visible=false;
}

// Hands results
hands.onResults((res)=>{
  const now = performance.now();
  if(res.multiHandLandmarks && res.multiHandLandmarks.length>0){
    const lm = res.multiHandLandmarks[0];
    updateHandVisuals(lm);

    // pointer pos
    handX = (lm[8].x - 0.5) * window.innerWidth * 0.06;
    handY = -(lm[8].y - 0.5) * window.innerHeight * 0.045;

    // pinch scale
    const dx = lm[4].x - lm[8].x, dy = lm[4].y - lm[8].y;
    scaleVal = Math.max(0.5, Math.sqrt(dx*dx + dy*dy) * 8);

    // fist
    const isFist = (lm[12].y > lm[9].y);
    currentShape = isFist ? 'heart' : 'sphere';

    // V sign -> color change
    const indexUp = lm[8].y < lm[6].y;
    const middleUp = lm[12].y < lm[10].y;
    const ringUp = lm[16].y < lm[14].y;
    if(indexUp && middleUp && !ringUp && now - cooldown.color > 700){
      colorMode = (colorMode + 1) % 3; cooldown.color = now; statusText.innerText='ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù„ÙˆÙ†';
    }

    // thumb up -> boost rotation
    const thumbUp = lm[4].y < lm[3].y;
    if(thumbUp && now - cooldown.boost > 800){
      cooldown.boost = now; rotSpeed = 0.02; setTimeout(()=>rotSpeed = 0.002, 500); statusText.innerText='Ø²ÙŠØ§Ø¯Ø© Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†';
    }

    // rock -> explosion
    const pinkyUp = lm[20].y < lm[18].y;
    const rock = indexUp && pinkyUp && (lm[12].y > lm[10].y);
    if(rock && now - cooldown.explosion > 900){
      cooldown.explosion = now;
      for(let i=0;i<COUNT;i++){ vel[i*3] += (Math.random()-.5)*8; vel[i*3+1] += (Math.random()-.5)*8; vel[i*3+2] += (Math.random()-.5)*8; }
      statusText.innerText='ØªÙØ¬ÙŠØ±!';
    }

    // open hand -> freeze
    const openHand = indexUp && middleUp && ringUp && pinkyUp;
    freeze = openHand;
    if(freeze) statusText.innerText = 'ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯';

    // wave history for reset
    if(!hands._wave) hands._wave = [];
    hands._wave.push(lm[8].x);
    if(hands._wave.length > 10) hands._wave.shift();
    const mn = Math.min(...hands._wave), mx = Math.max(...hands._wave);
    if(mx - mn > 0.36 && performance.now() - cooldown.reset > 900){
      cooldown.reset = performance.now();
      for(let i=0;i<COUNT;i++){
        positions[i*3] = (Math.random()-.5)*120; positions[i*3+1] = (Math.random()-.5)*120; positions[i*3+2] = (Math.random()-.5)*120;
        vel[i*3]=vel[i*3+1]=vel[i*3+2]=0;
      }
      statusText.innerText='Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·';
    }

  } else {
    updateHandVisuals(null);
    statusText.innerText = 'Ù„Ù… ØªÙÙƒØªØ´Ù ÙŠØ¯ â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
  }
});

// FaceMesh results -> mouth open sparks (use landmarks 13 & 14)
faceMesh.onResults((res)=>{
  const now = performance.now();
  if(res.multiFaceLandmarks && res.multiFaceLandmarks.length>0){
    const fl = res.multiFaceLandmarks[0];
    const a = fl[13], b = fl[14];
    if(a && b){
      const d = Math.hypot(a.x - b.x, a.y - b.y);
      if(d > 0.037 && now - cooldown.mouth > 900){
        cooldown.mouth = now;
        for(let k=0;k<Math.floor(COUNT/6);k++){
          const j = Math.floor(Math.random()*COUNT);
          vel[j*3] += (Math.random()-.5)*30; vel[j*3+1] += Math.random()*45; vel[j*3+2] += (Math.random()-.5)*30;
        }
        statusText.innerText='ÙØªØ­ Ø§Ù„ÙÙ…: Ø´Ø±Ø§Ø±!';
      }
    }
  }
});

// start camera (pass camPreview directly to Camera to avoid black preview)
startButton.onclick = async ()=>{
  overlay.style.display = 'none';
  statusText.innerText = 'Ø¬Ø§Ø±ÙŠ Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...';
  try{
    const cam = new Camera(videoEl, {
      onFrame: async ()=>{
        // send the current video frame to both models
        await hands.send({image: videoEl});
        await faceMesh.send({image: videoEl});
      },
      width: 640, height: 480
    });
    await cam.start();
    // ensure preview plays
    try{ videoEl.play(); }catch(e){ /* autoplay policy */ }
    statusText.innerText = 'ÙƒØ§Ù…ÙŠØ±Ø§ Ø´ØºÙ‘Ø§Ù„Ø© â€” Ù‚Ø±Ø¨ ÙŠØ¯Ùƒ ÙˆÙÙ…Ùƒ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
    animate();
  }catch(err){
    console.error('Camera start error', err);
    statusText.innerText = 'Ø®Ø·Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: ' + (err && err.message ? err.message : err);
    overlay.style.display = 'flex';
  }
};

// animation loop â€” use setXYZ for positions updates to ensure three.js sees them
let t = 0;
function animate(){
  requestAnimationFrame(animate);
  if(!freeze) t += 0.012;

  const attrPos = geo.attributes.position;
  const attrCol = geo.attributes.color;

  for(let i=0;i<COUNT;i++){
    const xIdx = i;
    // apply velocity
    positions[i*3] += vel[i*3]*0.02;
    positions[i*3+1] += vel[i*3+1]*0.02;
    positions[i*3+2] += vel[i*3+2]*0.02;

    // target
    const target = (currentShape === 'heart') ? heart((i/COUNT)*Math.PI*2).multiplyScalar(scaleVal*1.6) : spherePoint(i).multiplyScalar(scaleVal*1.2);
    const noise = Math.sin(t + i) * 0.6;

    const nx = positions[i*3] + (target.x + handX + noise - positions[i*3]) * 0.09;
    const ny = positions[i*3+1] + (target.y + handY + noise - positions[i*3+1]) * 0.09;
    const nz = positions[i*3+2] + (target.z - positions[i*3+2]) * 0.085;

    // update arrays and BufferAttribute via setXYZ (ensures internal updates)
    attrPos.setXYZ(i, nx, ny, nz);
    positions[i*3] = nx; positions[i*3+1] = ny; positions[i*3+2] = nz;

    // damping velocities
    vel[i*3] *= 0.93; vel[i*3+1] *= 0.93; vel[i*3+2] *= 0.93;

    // colors
    if(colorMode===0) attrCol.setXYZ(i, 0.6, 0.6, 1);
    else if(colorMode===1) attrCol.setXYZ(i, 1, 0.45, 0.5);
    else attrCol.setXYZ(i, 0.35, 0.95, 0.6);
  }

  attrPos.needsUpdate = true;
  attrCol.needsUpdate = true;
  threadGeom.attributes.position.needsUpdate = true;
  handLineGeom.attributes.position.needsUpdate = true;

  particles.rotation.y += rotSpeed;
  renderer.render(scene, camera);
}

// resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
