<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AR Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„ - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…ØµØ­Ø­Ø©</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #camPreview { position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
  canvas { position: fixed; inset: 0; z-index: 10; pointer-events: none; }
  #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; color: white; text-align: center; }
  button { padding: 15px 40px; border-radius: 50px; border: none; background: #00d1b2; color: white; cursor: pointer; font-size: 1.2rem; }
  #status { position: fixed; top: 10px; width: 100%; text-align: center; color: #00ff88; z-index: 100; font-weight: bold; background: rgba(0,0,0,0.3); }
</style>
</head>
<body>

<div id="overlay">
  <h1>Ù†Ø¸Ø§Ù… AR Ø§Ù„Ù…ØªØ·ÙˆØ±</h1>
  <p>ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØµÙˆØªØŒ Ø§Ù„ÙŠØ¯ØŒ ÙˆØ§Ù„Ø¬Ø³Ù… Ø¨Ø§Ù„ÙƒØ§Ù…Ù„</p>
  <button id="startButton">Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„</button>
</div>

<div id="status">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø±...</div>
<video id="camPreview" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// 1. Ø¥Ø¹Ø¯Ø§Ø¯ Three.js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 70;

// 2. Ù†Ø¸Ø§Ù… Ø§Ù„Ø´Ø±Ø§Ø± (Particles)
const COUNT = 1500;
const posArr = new Float32Array(COUNT * 3);
const colArr = new Float32Array(COUNT * 3);
const velArr = new Float32Array(COUNT * 3);
for(let i=0; i<COUNT*3; i++) posArr[i] = (Math.random()-0.5)*100;

const geo = new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
const mat = new THREE.PointsMaterial({ size: 0.8, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// 3. Ù†Ø¸Ø§Ù… Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø§Ù„Ø¬Ø³Ù… (Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø°ÙŠ ÙƒØ§Ù† Ù†Ø§Ù‚ØµØ§Ù‹)
const bodyLineMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, linewidth: 2 });
const bodyLineGeo = new THREE.BufferGeometry();
const bodyLines = new THREE.LineSegments(bodyLineGeo, bodyLineMat);
scene.add(bodyLines);

// Ø§Ù„Ø­Ø§Ù„Ø©
let targetPos = new THREE.Vector3(0,0,0);
let scaleVal = 1;
let currentShape = 'sphere';
let pColor = new THREE.Color(0x00ffff);

// --- Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„ØµÙˆØªÙŠ ---
const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
if(Speech) {
    const rec = new Speech();
    rec.continuous = true;
    rec.lang = 'ar-SA';
    rec.onresult = (e) => {
        const cmd = e.results[e.results.length-1][0].transcript.trim();
        if(cmd.includes("Ø£Ø­Ù…Ø±")) pColor.set(0xff0000);
        if(cmd.includes("Ø£Ø²Ø±Ù‚")) pColor.set(0x00ffff);
        if(cmd.includes("Ø§Ù†ÙØ¬Ø§Ø±")) {
            for(let i=0; i<COUNT*3; i++) velArr[i] += (Math.random()-0.5)*50;
        }
        statusText.innerText = "Ø£Ù…Ø± ØµÙˆØªÙŠ: " + cmd;
    };
    rec.start();
}

// 4. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
function to3D(lm) {
    return new THREE.Vector3(-(lm.x - 0.5) * 100, -(lm.y - 0.5) * 75, -lm.z * 50);
}

const holistic = new Holistic({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}` });
holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

holistic.onResults((res) => {
    const points = [];
    
    // Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø§Ù„Ø¬Ø³Ù… ÙˆØ§Ù„ÙŠØ¯ÙŠÙ†
    const drawLandmarks = (lms, connections) => {
        if(!lms) return;
        connections.forEach(([a, b]) => {
            if(lms[a] && lms[b]) {
                points.push(to3D(lms[a]), to3D(lms[b]));
            }
        });
    };

    if(res.poseLandmarks) {
        // Ø®Ø·ÙˆØ· Ø§Ù„Ø¬Ø³Ù…
        const poseConn = [[11,12], [11,23], [12,24], [23,24], [11,13], [13,15], [12,14], [14,16]];
        drawLandmarks(res.poseLandmarks, poseConn);
        scaleVal = Math.abs(res.poseLandmarks[11].x - res.poseLandmarks[12].x) * 5;
    }

    if(res.rightHandLandmarks) {
        // Ø®Ø·ÙˆØ· Ø§Ù„ÙŠØ¯
        const handConn = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12]];
        drawLandmarks(res.rightHandLandmarks, handConn);
        
        // ØªØªØ¨Ø¹ Ø§Ù„Ø³Ø¨Ø§Ø¨Ø© Ù„Ù„Ø´Ø±Ø§Ø±
        targetPos.lerp(to3D(res.rightHandLandmarks[8]), 0.2);

        // Ù…ÙŠØ²Ø© Ø§Ù„Ø³Ø­Ø¨ ğŸ¤
        const index = res.rightHandLandmarks[8];
        const thumb = res.rightHandLandmarks[4];
        if(Math.hypot(index.x-thumb.x, index.y-thumb.y) < 0.05) {
            statusText.innerText = "ØªÙ… Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ Ø¨Ø§Ù„Ø´ÙƒÙ„ ğŸ¤";
        }
    }

    bodyLineGeo.setFromPoints(points);
});

function animate() {
    requestAnimationFrame(animate);
    const pos = geo.attributes.position;
    const col = geo.attributes.color;

    for (let i = 0; i < COUNT; i++) {
        // ÙÙŠØ²ÙŠØ§Ø¡ Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
        posArr[i*3] += velArr[i*3] * 0.1;
        posArr[i*3+1] += velArr[i*3+1] * 0.1;
        posArr[i*3+2] += velArr[i*3+2] * 0.1;
        velArr[i*3] *= 0.9; velArr[i*3+1] *= 0.9; velArr[i*3+2] *= 0.9;

        // Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø°Ø¨ Ù„Ù„Ø´ÙƒÙ„
        const phi = Math.acos(-1 + 2*i/COUNT);
        const th = Math.sqrt(COUNT*Math.PI)*phi;
        const tx = Math.cos(th)*Math.sin(phi) * 15 * scaleVal + targetPos.x;
        const ty = Math.sin(th)*Math.sin(phi) * 15 * scaleVal + targetPos.y;
        const tz = Math.cos(phi) * 15 * scaleVal + targetPos.z;

        posArr[i*3] += (tx - posArr[i*3]) * 0.1;
        posArr[i*3+1] += (ty - posArr[i*3+1]) * 0.1;
        posArr[i*3+2] += (tz - posArr[i*3+2]) * 0.1;

        col.setXYZ(i, pColor.r, pColor.g, pColor.b);
    }
    pos.needsUpdate = true;
    col.needsUpdate = true;
    renderer.render(scene, camera);
}

startButton.onclick = () => {
    overlay.style.display = 'none';
    const cam = new Camera(videoEl, {
        onFrame: async () => { await holistic.send({ image: videoEl }); },
        width: 1280, height: 720
    });
    cam.start();
    animate();
};
</script>
</body>
</html>
