<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ - Ù†Ø³Ø®Ø© Ù…Ø·ÙˆØ±Ø©</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  /* Ø¬Ø¹Ù„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø¨Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© */
  #camPreview {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    object-fit: cover; transform: scaleX(-1); z-index: 1;
  }
  /* Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ ÙÙˆÙ‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ */
  canvas { position: fixed; top: 0; left: 0; z-index: 10; pointer-events: none; }
  
  #overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7);
    display: flex; align-items: center; justify-content: center;
    z-index: 1000; flex-direction: column; color: white;
  }
  button {
    padding: 15px 30px; border-radius: 30px; border: none;
    background: #00d1b2; color: white; cursor: pointer; font-size: 1.2rem;
  }
  #status {
    position: fixed; top: 20px; width: 100%; text-align: center;
    color: #00ff88; font-weight: bold; z-index: 100; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }
  #legend {
    position: fixed; bottom: 20px; right: 20px; padding: 15px;
    background: rgba(0,0,0,0.6); color: white; border-radius: 15px;
    z-index: 100; font-size: 0.8rem; pointer-events: none;
  }
</style>
</head>
<body>

<div id="overlay">
  <h2>ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙŠØ¯ (AR)</h2>
  <p>ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¶Ø§Ø¡Ø© Ø¬ÙŠØ¯Ø© Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¨Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ¯</p>
  <button id="startButton">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ¬Ø±Ø¨Ø©</button>
</div>

<div id="status">Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ´ØºÙŠÙ„...</div>

<div id="legend">
  <b>ğŸ® Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ§Øª:</b><br>
  â˜ï¸ Ø³Ø¨Ø§Ø¨Ø© ÙˆØ§Ø­Ø¯Ø©: ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª<br>
  âœŠ Ù‚Ø¨Ø¶Ø© ÙŠØ¯: Ø´ÙƒÙ„ Ù‚Ù„Ø¨ â¤ï¸<br>
  âœŒï¸ Ø¹Ù„Ø§Ù…Ø© V: ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù„ÙˆØ§Ù†<br>
  ğŸ‘ Ø¥Ø¨Ù‡Ø§Ù… Ù„Ù„Ø£Ø¹Ù„Ù‰: ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¯ÙˆØ±Ø§Ù†<br>
  ğŸ– ÙƒÙ Ù…ÙØªÙˆØ­: ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ø­Ø±ÙƒØ©
</div>

<video id="camPreview" autoplay muted playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

const startButton = document.getElementById('startButton');
const overlay = document.getElementById('overlay');
const statusText = document.getElementById('status');
const videoEl = document.getElementById('camPreview');

// Ø¥Ø¹Ø¯Ø§Ø¯ Three.js Ø¨Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ©
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0); // Ø´ÙØ§ÙÙŠØ© ÙƒØ§Ù…Ù„Ø©
document.body.appendChild(renderer.domElement);

camera.position.z = 50;

// Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
const COUNT = 1500;
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);
for(let i=0; i<COUNT; i++) {
    positions[i*3] = (Math.random()-0.5)*100;
    positions[i*3+1] = (Math.random()-0.5)*100;
    positions[i*3+2] = (Math.random()-0.5)*100;
}
geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const mat = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.8 });
const particles = new THREE.Points(geo, mat);
scene.add(particles);

// Ø®ÙŠÙˆØ· Ø§Ù„ÙŠØ¯ (Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¹Ø¸Ù…ÙŠ)
const handLinesGeo = new THREE.BufferGeometry();
const handLinesMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
const handLines = new THREE.LineSegments(handLinesGeo, handLinesMat);
scene.add(handLines);

// ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª MediaPipe Ø¥Ù„Ù‰ Three.js
function lmToScene(lm) {
    return {
        x: (lm.x - 0.5) * 60 * (window.innerWidth / window.innerHeight),
        y: -(lm.y - 0.5) * 60,
        z: -lm.z * 50
    };
}

let handX = 0, handY = 0, targetShape = 'sphere', colorMode = 0, rotSpeed = 0.005;

const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

hands.onResults((res) => {
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const lm = res.multiHandLandmarks[0];
        statusText.innerText = "ØªÙ… Ø±ØµØ¯ Ø§Ù„ÙŠØ¯ âœ…";

        // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙŠØ¯
        const p8 = lmToScene(lm[8]); // Ø§Ù„Ø³Ø¨Ø§Ø¨Ø©
        handX = p8.x;
        handY = p8.y;

        // Ø±Ø³Ù… Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙŠØ¯
        updateHandMesh(lm);

        // Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø­Ø±ÙƒØ§Øª
        detectGestures(lm);
    } else {
        statusText.innerText = "Ø¶Ø¹ ÙŠØ¯Ùƒ Ø£Ù…Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...";
        handLines.visible = false;
    }
});

function updateHandMesh(lm) {
    handLines.visible = true;
    const points = [];
    const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
    
    connections.forEach(([a, b]) => {
        const pA = lmToScene(lm[a]);
        const pB = lmToScene(lm[b]);
        points.push(new THREE.Vector3(pA.x, pA.y, pA.z));
        points.push(new THREE.Vector3(pB.x, pB.y, pB.z));
    });
    handLinesGeo.setFromPoints(points);
}

let lastColorChange = 0;
function detectGestures(lm) {
    const now = Date.now();
    
    // 1. Ø§Ù„Ù‚Ø¨Ø¶Ø© (Fist) -> Ù‚Ù„Ø¨
    const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
    targetShape = isFist ? 'heart' : 'sphere';

    // 2. Ø¹Ù„Ø§Ù…Ø© V -> ØªØºÙŠÙŠØ± Ù„ÙˆÙ†
    const isV = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y;
    if (isV && now - lastColorChange > 1000) {
        colorMode = (colorMode + 1) % 3;
        lastColorChange = now;
    }

    // 3. Ø¥Ø¨Ù‡Ø§Ù… Ù„Ù„Ø£Ø¹Ù„Ù‰ -> ØªØ³Ø±ÙŠØ¹
    const isThumbUp = lm[4].y < lm[3].y && lm[8].x > lm[5].x;
    rotSpeed = isThumbUp ? 0.05 : 0.005;
}

// Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª
const heartFn = (t) => ({
    x: 16 * Math.pow(Math.sin(t), 3) / 1.5,
    y: (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 1.5
});

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;
    const posAttr = geo.attributes.position;
    const colAttr = geo.attributes.color;

    for (let i = 0; i < COUNT; i++) {
        let tx, ty, tz = 0;
        if (targetShape === 'heart') {
            const t = (i / COUNT) * Math.PI * 2;
            const p = heartFn(t);
            tx = p.x + handX;
            ty = p.y + handY;
        } else {
            const angle = (i / COUNT) * Math.PI * 2;
            tx = Math.cos(angle + time) * 15 + handX;
            ty = Math.sin(angle + time) * 15 + handY;
        }

        // ØªØ­Ø±ÙŠÙƒ Ù†Ø§Ø¹Ù… Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
        posAttr.array[i*3] += (tx - posAttr.array[i*3]) * 0.1;
        posAttr.array[i*3+1] += (ty - posAttr.array[i*3+1]) * 0.1;
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù„ÙˆØ§Ù†
        if(colorMode === 0) { colAttr.setXYZ(i, 0, 1, 0.8); }
        else if(colorMode === 1) { colAttr.setXYZ(i, 1, 0.2, 0.5); }
        else { colAttr.setXYZ(i, 1, 1, 0); }
    }

    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    particles.rotation.y += rotSpeed;
    renderer.render(scene, camera);
}

startButton.onclick = async () => {
    overlay.style.display = 'none';
    const cameraHelper = new Camera(videoEl, {
        onFrame: async () => { await hands.send({ image: videoEl }); },
        width: 640, height: 480
    });
    cameraHelper.start();
    animate();
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

